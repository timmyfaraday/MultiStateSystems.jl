var documenterSearchIndex = {"docs":
[{"location":"distribution/#Distributions","page":"Distributions","title":"Distributions","text":"","category":"section"},{"location":"distribution/#Introduction","page":"Distributions","title":"Introduction","text":"","category":"section"},{"location":"distribution/","page":"Distributions","title":"Distributions","text":"The package includes a collection of probabilistic distributions and related functions. The implementation is heavily influenced by the package Distributions.jl, but extends it to allow for weighted distributions as well as the Unitful.jl parameters.","category":"page"},{"location":"distribution/#Distributions-2","page":"Distributions","title":"Distributions","text":"","category":"section"},{"location":"distribution/","page":"Distributions","title":"Distributions","text":"Each distribution has a number of constructors, both based on its full name and abbreviation, e.g., Weibull() is equivalent to ùëæ(). The abbreviation  constructor is the first letter of the distribution in the \\bi font. Furthermore, additional constructors are included for limited input, where all  remaining parameters are set to their default, e.g., Weibull(10.0u\"hr\") is  equivalent to Weibull(10.0u\"hr\",1.0,1.0).","category":"page"},{"location":"distribution/","page":"Distributions","title":"Distributions","text":"All input parameters are either of the type Number, its subtype Real or a  Function:","category":"page"},{"location":"distribution/","page":"Distributions","title":"Distributions","text":"Number\n |- Unitful.Quantity, e.g., 10.0u\"hr\"\n |- Real\n     |- AbstractFloat, e.g., 10.0\n     |- Integer, e.g., 10\nFunction","category":"page"},{"location":"distribution/","page":"Distributions","title":"Distributions","text":"All distributions may be scaled using a weight parameter œâ, where 0.0 < œâ::Real ‚â§ 1.0 or 0.0 < œâ(t)::Fuction ‚â§ 1.0.","category":"page"},{"location":"distribution/#Exponential-Distribution","page":"Distributions","title":"Exponential Distribution","text":"","category":"section"},{"location":"distribution/","page":"Distributions","title":"Distributions","text":"The exponential distribution with scale parameter Œ∏ and an optional weight œâ has a probability density function","category":"page"},{"location":"distribution/","page":"Distributions","title":"Distributions","text":"f(x Œ∏ œâ) = begincases\n                œâŒ∏ e^-xŒ∏     x  0 \n                0                x  0\n             endcases","category":"page"},{"location":"distribution/#Weibull-Distribution","page":"Distributions","title":"Weibull Distribution","text":"","category":"section"},{"location":"distribution/","page":"Distributions","title":"Distributions","text":"The Weibull distribution with scale parameter Œ∏, shape parameter Œ± and optional weight œâ has a probability density function","category":"page"},{"location":"distribution/","page":"Distributions","title":"Distributions","text":"f(x Œ∏ Œ± œâ) = begincases\n                    fracŒ±œâŒ∏ cdot big(fracxŒ∏big)^Œ±-1 cdot e^-big(fracxŒ∏big)^Œ±  textifx  0 \n                    0                                                                                 textifx  0\n                endcases","category":"page"},{"location":"distribution/#Constructors","page":"Distributions","title":"Constructors","text":"","category":"section"},{"location":"distribution/","page":"Distributions","title":"Distributions","text":"Full Abbr. Description\nWeibull(Œ∏,Œ±,œâ) ùëæ(Œ∏,Œ±,œâ) full constructor\nWeibull(Œ∏,Œ±) ùëæ(Œ∏,Œ±) constructor which defaults to Weibull(Œ∏,Œ±,1.0)\nWeibull(Œ∏) ùëæ(Œ∏) constructor which defaults to Weibull(Œ∏,1.0,1.0)\nWeibull() ùëæ() empty constructor which defaults to Weibull(1.0,1.0,1.0)","category":"page"},{"location":"distribution/#Examples","page":"Distributions","title":"Examples","text":"","category":"section"},{"location":"distribution/","page":"Distributions","title":"Distributions","text":"julia> Weibull()            # default Weibull distr. with Œ∏ = 1.0, Œ± = 1.0 and œâ = 1.0\njulia> ùëæ(3.0u\"minute\")     # Weibull distr. with Œ∏ = 3.0 min, Œ± = 1.0 and œâ = 1.0\njulia> ùëæ(5.0u\"yr\",4.0)     # Weibull distr. with Œ∏ = 5.0 yr, Œ± = 4.0 and œâ = 1.0\njulia> ùëæ(10.0,0.5,0.2)     # scaled Weibull distr. with Œ∏ = 10.0, Œ± = 0.5 and œâ = 0.2","category":"page"},{"location":"distribution/#LogNormal-Distribution","page":"Distributions","title":"LogNormal Distribution","text":"","category":"section"},{"location":"distribution/","page":"Distributions","title":"Distributions","text":"The Log-normal distribution with expected value Œº and standard deviation œÉ of the corresponding normal distribution and optional weight œâ has a probability density function","category":"page"},{"location":"distribution/","page":"Distributions","title":"Distributions","text":"f(x Œº œÉ œâ) = begincases\n                    fracœâsqrt2œÄ x œÉ cdot cdot e^-big(frac(lnx-Œº)^22 œÉ^2big)   textifx  0 \n                    0                                                                                           textifx  0\n                endcases","category":"page"},{"location":"distribution/","page":"Distributions","title":"Distributions","text":"Given the ln-function, all Unitful values are converted to correspond with the unit of Œº.","category":"page"},{"location":"distribution/#Constructors-2","page":"Distributions","title":"Constructors","text":"","category":"section"},{"location":"distribution/","page":"Distributions","title":"Distributions","text":"Full Abbr. Description\nLogNormal(Œº,œÉ,œâ) ùë≥(Œº,œÉ,œâ) full constructor\nLogNormal(Œº,œÉ) ùë≥(Œº,œÉ) constructor which defaults to LogNormal(Œº,œÉ,1.0)\nLogNormal(Œº) ùë≥(Œº) constructor which defaults to LogNormal(Œº,1.0,1.0)\nLogNormal() ùë≥() empty constructor which defaults to LogNormal(1.0,1.0,1.0)","category":"page"},{"location":"distribution/#Examples-2","page":"Distributions","title":"Examples","text":"","category":"section"},{"location":"distribution/","page":"Distributions","title":"Distributions","text":"julia> LogNormal()          # default Log-normal distr. with Œº = 1.0, œÉ = 1.0 and œâ = 1.0\njulia> ùë≥(3.0u\"minute\")      # Log-normal distr. with Œº = 3.0 min, œÉ = 1.0 min and œâ = 1.0\njulia> ùë≥(5.0u\"yr\",4.0u\"d\")  # Log-normal distr. with Œº = 5.0 yr, œÉ = 4.0 d and œâ = 1.0\njulia> ùë≥(10.0,0.5,0.2)      # scaled Log-normal distr. with Œº = 10.0, œÉ = 0.5 and œâ = 0.2","category":"page"},{"location":"indices/#Indices","page":"Indices","title":"Indices","text":"","category":"section"},{"location":"indices/#Introduction","page":"Indices","title":"Introduction","text":"","category":"section"},{"location":"indices/","page":"Indices","title":"Indices","text":"Indices attempt to quantitatively assess the reliability of a system using a single numerical value. ","category":"page"},{"location":"indices/#Expected-Energy-Not-Served-(EENS)-[MWh]","page":"Indices","title":"Expected Energy Not Served (EENS) [MWh]","text":"","category":"section"},{"location":"indices/","page":"Indices","title":"Indices","text":"This is the amount of electricity demand of a user, measured in MWh, that is expected not to be met in a given year. ","category":"page"},{"location":"indices/","page":"Indices","title":"Indices","text":"MultiStateSystems.EENS(usr::MultiStateSystems.PropDict)","category":"page"},{"location":"indices/#MultiStateSystems.EENS-Tuple{Dict{Symbol, Any}}","page":"Indices","title":"MultiStateSystems.EENS","text":"EENS(usr::MultiStateSystems.PropDict)\n\nExpected Energy Not Served (EENS) [MWh]\n\nEENS(usr) gives the EENS when an user's demand equals the maximal output of  the system for that user.\n\n\n\n\n\n","category":"method"},{"location":"indices/#Generation-Ratio-Availability-(GRA)-[-]","page":"Indices","title":"Generation Ratio Availability (GRA) [-]","text":"","category":"section"},{"location":"indices/","page":"Indices","title":"Indices","text":"This is the probability of at least transferring a specific percentage of the generation to a user through the network.","category":"page"},{"location":"indices/","page":"Indices","title":"Indices","text":"MultiStateSystems.GRA(usr::MultiStateSystems.PropDict)","category":"page"},{"location":"indices/#MultiStateSystems.GRA-Tuple{Dict{Symbol, Any}}","page":"Indices","title":"MultiStateSystems.GRA","text":"GRA(usr::MultiStateSystems.PropDict)\n\nGeneration Ratio Availability (GRA) [-]\n\nGRA(usr,GR) gives the probability of transferring at least the GR to a user through the network.\nGRA(usr) gives a user's GRA for a GR ranging from 0.0 to 1.0.\nGRO(usr,GR) gives the output towards a user for a given GR\n\n\n\n\n\n","category":"method"},{"location":"ugf/#Universal-Generating-Function","page":"Generating Functions","title":"Universal Generating Function","text":"","category":"section"},{"location":"ugf/#Introduction","page":"Generating Functions","title":"Introduction","text":"","category":"section"},{"location":"ugf/","page":"Generating Functions","title":"Generating Functions","text":"An universal generating function (abbr: ugf) approach approach enables the combination of components and sources to evaluate their performance with respect to a network's users.","category":"page"},{"location":"ugf/","page":"Generating Functions","title":"Generating Functions","text":"An universal generator function œâ_x(z) of a component/source x combines the probabilities p and associated values v of a specific measure m in one polynomial expression:","category":"page"},{"location":"ugf/","page":"Generating Functions","title":"Generating Functions","text":"    œâ_x(z) = sum_o in mathcalO p_o cdot z^v_o","category":"page"},{"location":"ugf/","page":"Generating Functions","title":"Generating Functions","text":"where ùìû is the reduced state-space which only contains unique values for a specific measure.","category":"page"},{"location":"ugf/","page":"Generating Functions","title":"Generating Functions","text":"MultiStateSystems.UGF","category":"page"},{"location":"ugf/#MultiStateSystems.UGF","page":"Generating Functions","title":"MultiStateSystems.UGF","text":"UGF\n\nAn ugf is a struct containing: a measure msr, corresponding values val and  associated probabilities prb, with default constructor: \n\nUGF(msr::Symbol, val::Vector, prb::Vector; red::Bool=true)\n\nA UGF constructor for a specific measure msr based on a given value vector  val and associated probability vector prb.\n\nThis function automatically reduces the state-space to where only unique values and associated probabilites remain. This behavior is circumvented by passing the optional argument rdc=false.\n\nExample\n\njulia> ugf·µç·µâ‚Åø = UGF(:power, [0.0u\"MW\",0.0u\"MW\",2.0u\"MW\"], [0.1,0.2,0.7])\njulia> isequal(ugf·µç·µâ‚Åø.val, [0.0u\"MW\",2.0u\"MW\"])\ntrue\njulia> ugf·µç·µâ‚Åø = UGF(:power, [0.0u\"MW\",0.0u\"MW\",2.0u\"MW\"], [0.1,0.2,0.7], rdc=false)\njulia> isequal(ugf·µç·µâ‚Åø.val, [0.0u\"MW\",0.0u\"MW\",2.0u\"MW\"])\ntrue\n\n\n\n\n\n","category":"type"},{"location":"ugf/","page":"Generating Functions","title":"Generating Functions","text":"Alternatively, an ugf may be constructed based on a solved state-transition diagram:","category":"page"},{"location":"ugf/","page":"Generating Functions","title":"Generating Functions","text":"MultiStateSystems.UGF(msr::Symbol, std::MultiStateSystems.AbstractSTD)","category":"page"},{"location":"ugf/#MultiStateSystems.UGF-Tuple{Symbol, MultiStateSystems.AbstractSTD}","page":"Generating Functions","title":"MultiStateSystems.UGF","text":"UGF(msr::Symbol, std::MultiStateSystems.AbstractSTD)\n\nA UGF constructor for a specific measure msr based on a given state-transition diagram std.\n\nThis function automatically reduces the state-space to where only unique values and associated probabilites remain.\n\nExample\n\njulia> std·µç·µâ‚Åø = solvedSTD(prob  = [0.1,0.2,0.7],\n                          power = [0.0u\"MW\",0.0u\"MW\",2.0u\"MW\"])\njulia> ugf·µç·µâ‚Åø = UGF(:power, std·µç·µâ‚Åø)\njulia> isequal(ugf·µç·µâ‚Åø.val,[0.0u\"MW\",2.0u\"MW\"])\ntrue\n\n\n\n\n\n","category":"method"},{"location":"std/#State-Transition-Diagram","page":"State-Transition Diagram","title":"State-Transition Diagram","text":"","category":"section"},{"location":"std/#Quick-Links","page":"State-Transition Diagram","title":"Quick Links","text":"","category":"section"},{"location":"std/","page":"State-Transition Diagram","title":"State-Transition Diagram","text":"Pages = [\"std.md\"]","category":"page"},{"location":"std/#Introduction","page":"State-Transition Diagram","title":"Introduction","text":"","category":"section"},{"location":"std/","page":"State-Transition Diagram","title":"State-Transition Diagram","text":"In its essence, a state-transition diagram (abbr: std) is a collections of states and transitions mapped onto a directed graph through metadata on its vertices and edges, respectively.","category":"page"},{"location":"std/","page":"State-Transition Diagram","title":"State-Transition Diagram","text":"Any state-transition diagram has four attributes:","category":"page"},{"location":"std/","page":"State-Transition Diagram","title":"State-Transition Diagram","text":"a directed graph std.graph::SimpleDiGraph\nstate-transition diagram properties std.props::PropDict\nstate properties std.sprops::Dict{Int,PropDict}\ntransition properties std.tprops::Dict{Edge,PropDict}","category":"page"},{"location":"std/#Constructors","page":"State-Transition Diagram","title":"Constructors","text":"","category":"section"},{"location":"std/","page":"State-Transition Diagram","title":"State-Transition Diagram","text":"An empty constructor is implemented:","category":"page"},{"location":"std/","page":"State-Transition Diagram","title":"State-Transition Diagram","text":"MultiStateSystems.STD()","category":"page"},{"location":"std/#MultiStateSystems.STD-Tuple{}","page":"State-Transition Diagram","title":"MultiStateSystems.STD","text":"STD()\n\nAn empty state-transition diagram constructor.\n\nExample\n\njulia> std·µç·µâ‚Åø = STD()\n\n\n\n\n\n","category":"method"},{"location":"std/#Info","page":"State-Transition Diagram","title":"Info","text":"","category":"section"},{"location":"std/","page":"State-Transition Diagram","title":"State-Transition Diagram","text":"A number of properties are defined for state-transition diagrams, states and transitions, respectively captured by (a) STDInfo, (b) StateInfo and (c) TransInfo.","category":"page"},{"location":"std/","page":"State-Transition Diagram","title":"State-Transition Diagram","text":"markovian [(a),(c)]:   the Markov property refers   to the memoryless property of a stochastic process. It entails that the   conditional probability distribution of future states only depends on the   present state, including calendar time, however, they are independent of the   present state's sojourn time (see: strong Markov property).\nrenewal [(a), (b), (c)]:   the renewal property entails that the stochastic process probabilistically start   over at each arrival epoch. Consequently, a non-renewal transition entails that   its to-state is not necessarily entered with a zero sojourn time.\ntime_homogeneous [(a), (c)]:   the time-homogeneous property   entails that the transition probability between two given states at any two   times depends only on the difference between those times and not on the calendar time at which the transition occured.\ntrapping [(b)]:   the trapping property entails that a state is only partially/never exited upon   entering.\nsolved [(a)]:   the solved property describes whether the state probabilities of a   state-transition diagram have been determined.","category":"page"},{"location":"std/#State","page":"State-Transition Diagram","title":"State","text":"","category":"section"},{"location":"std/","page":"State-Transition Diagram","title":"State-Transition Diagram","text":"Any state is represented by a PropDict mapped onto the vertices of the directed graph std.graph. The collection of all states is stored in std.sprops which is a dictionary indexed using the vertex ids [Int].","category":"page"},{"location":"std/","page":"State-Transition Diagram","title":"State-Transition Diagram","text":"Any property may be added the PropDict representing a state, however certain properties are reserved for specific functionality of the tool, each linked to a specific key [Symbol].","category":"page"},{"location":"std/","page":"State-Transition Diagram","title":"State-Transition Diagram","text":":info is reserved for the StateInfo\n:init is reserved for the initial state probability p(0) [-]\n:prob is reserved for the state probability p(t) [-]\n:flow is reserved for the state flow measure [m¬≥/hr]\n:power is reserved for the state power measure [MW]","category":"page"},{"location":"std/","page":"State-Transition Diagram","title":"State-Transition Diagram","text":"States may either be added to state-transition diagram individually or grouped using, respectively:","category":"page"},{"location":"std/","page":"State-Transition Diagram","title":"State-Transition Diagram","text":"MultiStateSystems.add_state!(std::MultiStateSystems.AbstractSTD; kwargs...)","category":"page"},{"location":"std/#MultiStateSystems.add_state!-Tuple{MultiStateSystems.AbstractSTD}","page":"State-Transition Diagram","title":"MultiStateSystems.add_state!","text":"add_state!(std::MultiStateSystems.AbstractSTD; kwargs...)\n\nAdds a single state to the state-transition diagram std and fills its corresponding PropDict with the named arguments kwargs.\n\nExample\n\njulia> std·µç·µâ‚Åø = STD()\njulia> add_state!(std·µç·µâ‚Åø, name  = \"normal operation state\",\n                          power = 100u\"MW\",\n                          init  = 1.0)\n\n\n\n\n\n","category":"method"},{"location":"std/","page":"State-Transition Diagram","title":"State-Transition Diagram","text":"MultiStateSystems.add_states!(std::MultiStateSystems.AbstractSTD; kwargs...)","category":"page"},{"location":"std/#MultiStateSystems.add_states!-Tuple{MultiStateSystems.AbstractSTD}","page":"State-Transition Diagram","title":"MultiStateSystems.add_states!","text":"add_states!(std::MultiStateSystems.AbstractSTD; kwargs...)\n\nAdds multiple states to the state-transition diagram std and fills their corresponding PropDict with the named arguments kwargs. Either an uniform argument is given which holds for all states or an array is given with the specific argument for each state.\n\nExample\n\njulia> std·µç·µâ‚Åø = STD()\njulia> add_states!(std·µç·µâ‚Åø, name  = [\"normal operation state\",\"failed state\"],\n                           power = [100.0u\"MW\",0.0u\"MW\"],\n                           init  = [1.0,0.0],\n                           markovian = true)\n\n\n\n\n\n","category":"method"},{"location":"std/#Transition","page":"State-Transition Diagram","title":"Transition","text":"","category":"section"},{"location":"std/","page":"State-Transition Diagram","title":"State-Transition Diagram","text":"Any transition is represented by a PropDict mapped onto the edges of the directed graph std.graph. The collection of all transitions is stored in std.tprops which is a dictionary indexed using the edge ids [Edge].","category":"page"},{"location":"std/","page":"State-Transition Diagram","title":"State-Transition Diagram","text":"Any property may be added to the PropDict representing a transition, however certain properties are reserved for specific functionality of the tool, each linked to a specific key [Symbol].","category":"page"},{"location":"std/","page":"State-Transition Diagram","title":"State-Transition Diagram","text":":states is reserved for the tuple (fr,to) of the from- and to-state\n:rate is reserved for the transition rate rho(tœÜ) [1/hr]\n:distr is reserved for the transition distribution","category":"page"},{"location":"std/","page":"State-Transition Diagram","title":"State-Transition Diagram","text":"Transitions may either be added to a state-transition diagram individually or grouped using, respectively:","category":"page"},{"location":"std/","page":"State-Transition Diagram","title":"State-Transition Diagram","text":"MultiStateSystems.add_transition!(std::MultiStateSystems.AbstractSTD; kwargs...)","category":"page"},{"location":"std/#MultiStateSystems.add_transition!-Tuple{MultiStateSystems.AbstractSTD}","page":"State-Transition Diagram","title":"MultiStateSystems.add_transition!","text":"add_transition!(std::MultiStateSystems.AbstractSTD; kwargs...)\n\nAdds a single transitions to the state-transition diagram std and fills its corresponding PropDict with the named arguments kwargs. One obligatory named argument is :states, describing the tuple (fr,to) of the from- and to-state.\n\nExample\n\njulia> std·µç·µâ‚Åø = STD()\njulia> add_states!(std·µç·µâ‚Åø, name  = [\"normal operation state\",\"failed state\"],\n                           power = [100.0u\"MW\",0.0u\"MW\"],\n                           init  = [1.0,0.0],\n                           markovian = true)\njulia> add_transition!(std·µç·µâ‚Åø, rate = 0.001u\"1/hr\",\n                               states = (1,2))\n\n\n\n\n\n","category":"method"},{"location":"std/","page":"State-Transition Diagram","title":"State-Transition Diagram","text":"MultiStateSystems.add_transitions!(std::MultiStateSystems.AbstractSTD; kwargs...)","category":"page"},{"location":"std/#MultiStateSystems.add_transitions!-Tuple{MultiStateSystems.AbstractSTD}","page":"State-Transition Diagram","title":"MultiStateSystems.add_transitions!","text":"add_transitions!(std::MultiStateSystems.AbstractSTD; kwargs...)\n\nAdds multiple transitions to the state-transition diagram std and fills their corresponding PropDict with the named arguments kwargs. Either an uniform argument is given which holds for all transitions or an array is given with the specific argument for each transition.\n\nExample\n\njulia> std·µç·µâ‚Åø = STD()\njulia> add_states!(std·µç·µâ‚Åø, name  = [\"normal operation state\",\"failed state\"],\n                           power = [100.0u\"MW\",0.0u\"MW\"],\n                           init  = [1.0,0.0],\n                           markovian = true)\njulia> add_transitions!(std·µç·µâ‚Åø, rate = [0.001u\"1/hr\",0.01u\"1/hr\"],\n                                states = [(1,2),(2,1)])\n\nnote: Note\nIf the :states argument is not provided in the add_transitions! function, the from- and to-states will be determined based on the other arguments.\n\nExample (Alternative)\n\njulia> add_transitions!(std·µç·µâ‚Åø, rate = [0.000u\"1/hr\" 0.010u\"1/hr\"\n                                        0.001u\"1/hr\" 0.000u\"1/hr\"])\n\n\n\n\n\n","category":"method"},{"location":"ugo/#Universal-Generating-Operator","page":"Generating Operators","title":"Universal Generating Operator","text":"","category":"section"},{"location":"ugo/#Introduction","page":"Generating Operators","title":"Introduction","text":"","category":"section"},{"location":"ugo/","page":"Generating Operators","title":"Generating Operators","text":"Solving a network ntw through the univeral generating operator may be accomplished through:","category":"page"},{"location":"ugo/","page":"Generating Operators","title":"Generating Operators","text":"solve!(ntw::MultiStateSystems.AbstractNetwork; type::Symbol=:steady)","category":"page"},{"location":"ugo/#MultiStateSystems.solve!-Tuple{MultiStateSystems.AbstractNetwork}","page":"Generating Operators","title":"MultiStateSystems.solve!","text":"solve!(ntw::MultiStateSystems.AbstractNetwork)\n\nThis function determines the universal generating function related to the output of all users usr of a network ntw.\n\n\n\n\n\n","category":"method"},{"location":"processes/#Stochastic-Processes","page":"Stochastic Processes","title":"Stochastic Processes","text":"","category":"section"},{"location":"processes/#Introduction","page":"Stochastic Processes","title":"Introduction","text":"","category":"section"},{"location":"processes/","page":"Stochastic Processes","title":"Stochastic Processes","text":"A number of stochastic processes are available to determine the state probabilities of an std:","category":"page"},{"location":"processes/","page":"Stochastic Processes","title":"Stochastic Processes","text":"AbstractStochasticProcess\n  |- AbstractMarkovProcess\n      |- SteadyStateProcess\n      |- MarkovProcess\n  |- AbstractSemiMarkovProcess\n      |- SemiMarkovProcess","category":"page"},{"location":"processes/","page":"Stochastic Processes","title":"Stochastic Processes","text":"Solving a stochastic process may be accomplished through excecuting: solve(std, cls; tsim, dt, tol), where cls denotes the class of stochastic process you want to use.","category":"page"},{"location":"processes/#Steady-State-Process","page":"Stochastic Processes","title":"Steady State Process","text":"","category":"section"},{"location":"processes/","page":"Stochastic Processes","title":"Stochastic Processes","text":"Spaces  Properties \nState-space discrete Renewal ‚úÖ\nTime-space singular (t=‚àû) Markov ‚úÖ","category":"page"},{"location":"processes/","page":"Stochastic Processes","title":"Stochastic Processes","text":"A steady state process determines the state-state probability of the state space associated with a time-homogeneous Markov process/chain, i.e., where t‚Üí‚àû.","category":"page"},{"location":"processes/","page":"Stochastic Processes","title":"Stochastic Processes","text":"https://www.maplesoft.com/support/help/maple/view.aspx?path=examples/SteadyStateMarkovChain","category":"page"},{"location":"processes/#Markov-Process","page":"Stochastic Processes","title":"Markov Process","text":"","category":"section"},{"location":"processes/","page":"Stochastic Processes","title":"Stochastic Processes","text":"Spaces  Properties \nState-space discrete Renewal ‚úÖ\nTime-space continuous Markov ‚úÖ","category":"page"},{"location":"processes/","page":"Stochastic Processes","title":"Stochastic Processes","text":"A Markov process is described by a random variable X_t, where t denotes the calendar time. The possible values of X_t are represented by the discrete state-space ùì¢ of the state transition diagram std.","category":"page"},{"location":"processes/","page":"Stochastic Processes","title":"Stochastic Processes","text":"A Markov process respects the Markov property, which means it respects","category":"page"},{"location":"processes/","page":"Stochastic Processes","title":"Stochastic Processes","text":"‚Ñô(X_t  ùì¢  ùìï_s) = ‚Ñô(X_t  ùì¢  X_s)  st  ùïÄ s  t","category":"page"},{"location":"processes/","page":"Stochastic Processes","title":"Stochastic Processes","text":"where ùìï_s represents a filtration of a probability space (Œ©,ùìï,‚Ñô) and ùïÄ a totally ordered index set. A Markov process is described by Kolmogorov equations, more specifically the Kolmogorov forward equations:","category":"page"},{"location":"processes/","page":"Stochastic Processes","title":"Stochastic Processes","text":" Œ¥p_ij(st)Œ¥t = _k p_ik(st)  A_kj(t)  ij  ùì¢ st  ùïÄ s  t","category":"page"},{"location":"processes/","page":"Stochastic Processes","title":"Stochastic Processes","text":"where A(t) represents the transition matrix, syn., generator matrix. The latter may be translated into an initial value problem for finding the state probabilities, given transition rates œÅ_ij(t) and initial values Œ¥_i:","category":"page"},{"location":"processes/","page":"Stochastic Processes","title":"Stochastic Processes","text":"dp_i(t)dt = - _j œÅ_ij(t)p_i(t) + _j œÅ_ji(t)p_j(t)   i  ùì¢","category":"page"},{"location":"processes/#Semi-Markov-Process","page":"Stochastic Processes","title":"Semi-Markov Process","text":"","category":"section"},{"location":"processes/","page":"Stochastic Processes","title":"Stochastic Processes","text":"Spaces  Properties \nState-space discrete Renewal ‚úÖ\nTime-space continuous Markov ‚ùé","category":"page"},{"location":"processes/","page":"Stochastic Processes","title":"Stochastic Processes","text":"A semi-Markov process is described by a random variable X_t, where t denotes the calendar time. The possible values of X_t are represented by the discrete state-space ùì¢ of the state transition diagram std.","category":"page"},{"location":"processes/","page":"Stochastic Processes","title":"Stochastic Processes","text":"A semi-Markov process...","category":"page"},{"location":"processes/#Van-Acker-Process","page":"Stochastic Processes","title":"Van Acker Process","text":"","category":"section"},{"location":"processes/","page":"Stochastic Processes","title":"Stochastic Processes","text":"T. Van Acker, and D. Van Hertem (2018). Stochastic Process for the  Availability Assessment of Single-Feeder Industrial Energy System Sections.  IEEE Trans. on Rel., 67(4), 1459-1467.","category":"page"},{"location":"processes/","page":"Stochastic Processes","title":"Stochastic Processes","text":"Spaces  Properties \nState-space semi-continuous Renewal ‚ùé[1]\nTime-space continuous Markov ‚ùé","category":"page"},{"location":"processes/","page":"Stochastic Processes","title":"Stochastic Processes","text":"[1]: The normal operation state can be a non-renewal state, enabling imperfect   maintenance.","category":"page"},{"location":"processes/","page":"Stochastic Processes","title":"Stochastic Processes","text":"An Van Acker process is described by a random variable X_tœÜ, where t denotes the calendar time. The possible values of X_tœÜ are represented by the semi-continuous state-space ùì¢ of the state transition diagram std and œÜ_s denotes its state sojourn time.","category":"page"},{"location":"processes/","page":"Stochastic Processes","title":"Stochastic Processes","text":"An Van Acker process is described by a single PDDE with non-local boundary condition for the normal operation state n  ùìù, from which all state probabilies of the other states may be derived.","category":"page"},{"location":"processes/","page":"Stochastic Processes","title":"Stochastic Processes","text":"beginaligned\nfracp_nœÜ_n + fracp_nt = - sum_f  ùìï Œª_f(tœÜ_n) p_n(tœÜ_n)                            \n                                           + sum_f  ùìï^textmin (ùñø_f * Œª_fp_n)(tœÜ_n)                \n                              p_n(t0)  =   sum_f  ùìï^textper int_0^ (ùñø_f * Œª_fp_n)(tœÜ_n) ùñΩœÜ_f\nendaligned","category":"page"},{"location":"processes/","page":"Stochastic Processes","title":"Stochastic Processes","text":"where, ùìï, ùìï^textmin and ùìï^textper denote the overall failure set and the failure sets respecively involving minimal and perfect maintenance. The parameters Œª_f and ùñø_f respectively denote the failure rate and restoration pdf associated with a specific failure f  ùìï. The restoration pdf is the sum of the convolutions of transition pdf's along all paths involving a specific failure f  ùìï but excluding that failure's transition pdf.","category":"page"},{"location":"processes/","page":"Stochastic Processes","title":"Stochastic Processes","text":"!!! The normal operation state is selected by setting that state's initial value  :init to 1.0.","category":"page"},{"location":"processes/","page":"Stochastic Processes","title":"Stochastic Processes","text":"The problem structure permits descretization of the solution space into cohorts a  ùìê t = œÜ_n + t_a, where t_a is the time for which a cohort a has a zero sojourn time œÜ_n; translating the PDDE into an non-homogeneous first order ODE.","category":"page"},{"location":"processes/","page":"Stochastic Processes","title":"Stochastic Processes","text":"beginaligned\nfracùñΩp_anùñΩœÜ_n = - sum_f  ùìï Œª_af(œÜ_n) p_an(œÜ_n)                                         \n                         + sum_f  ùìï^textmin sum_x  ùìß barùñø_fx Œª_a-xf(œÜ_n) p_a-xn(œÜ_n) \n            p_an(0)  =   sum_f  ùìï^textper sum_x  ùìß barùñø_fx Œª_a-xf(œÜ_f) p_a-xn(œÜ_f) ùñΩœÜ_f\nendaligned","category":"page"},{"location":"processes/","page":"Stochastic Processes","title":"Stochastic Processes","text":"Using the solution for the normal operation state probability, all other state probabilities p_p(tvarphi_p)p  ùìü may be determined.","category":"page"},{"location":"processes/","page":"Stochastic Processes","title":"Stochastic Processes","text":"beginaligned\np_p(tvarphi_p)  = sum_c  ùìí_p f  c (ùñø^textpre_cp*p_f)(t-œÜ_p) R_cp(œÜ_p)   \np_f(t)              = int_0^infty Œª_f(tœÜ_n) p_n(tvarphi_n)ùñΩœÜ_n\nendaligned","category":"page"},{"location":"processes/","page":"Stochastic Processes","title":"Stochastic Processes","text":"where ùìí_p is the set of simple cycles going through the state p and the pdf ùó≥^textpre_cp convolutions of the transition pdf's of a cycle starting from the normal operation state n up to state p excluding the failure transition.","category":"page"},{"location":"dependence/#Dependence","page":"Dependence","title":"Dependence","text":"","category":"section"},{"location":"dependence/#Quick-Links","page":"Dependence","title":"Quick Links","text":"","category":"section"},{"location":"dependence/","page":"Dependence","title":"Dependence","text":"Pages = [\"dependence.md\"]","category":"page"},{"location":"dependence/#Introduction","page":"Dependence","title":"Introduction","text":"","category":"section"},{"location":"dependence/","page":"Dependence","title":"Dependence","text":"Many forms of dependence exists ","category":"page"},{"location":"dependence/#Evaluation-Dependence","page":"Dependence","title":"Evaluation Dependence","text":"","category":"section"},{"location":"#MultiStateSystems.jl","page":"Home","title":"MultiStateSystems.jl","text":"","category":"section"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"MultiStateSystems.jl is a Julia package (v1.8+) to solve multi-state systems, often found in reliability engineering.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The latest stable release of MultiStateSystems can be installed using the Julia package manager:","category":"page"},{"location":"","page":"Home","title":"Home","text":"] add MultiStateSystems","category":"page"},{"location":"","page":"Home","title":"Home","text":"In order to test whether the package works, run:","category":"page"},{"location":"","page":"Home","title":"Home","text":"] test MultiStateSystems","category":"page"},{"location":"#Acknowledgements","page":"Home","title":"Acknowledgements","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The primary developer is Tom Van Acker (@timmyfaraday), BASF,  with support from the following contributors:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Glenn Emmers (@glenn-sergej), KU Leuven, semi-Markov implementation, LVDC examples\nGayan Abeynayake (@gayan86), √òrsted, Anholt wind farm example","category":"page"},{"location":"#License","page":"Home","title":"License","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This code is provided under a BSD license.","category":"page"},{"location":"network/#Network","page":"Network","title":"Network","text":"","category":"section"},{"location":"network/#Quick-Links","page":"Network","title":"Quick Links","text":"","category":"section"},{"location":"network/","page":"Network","title":"Network","text":"Pages = [\"network.md\"]","category":"page"},{"location":"network/#Introduction","page":"Network","title":"Introduction","text":"","category":"section"},{"location":"network/","page":"Network","title":"Network","text":"In its essence, a network (abbr: ntw) is a collection of sources, components and users mapped onto a directed multigraph.","category":"page"},{"location":"network/","page":"Network","title":"Network","text":"Any network has eight attributes:","category":"page"},{"location":"network/","page":"Network","title":"Network","text":"a multigraph ntw.graph::DiMultigraph\nnetwork properties ntw.props::PropDict\ncomponents ntw.cmp::Vector{PropDict}\nsources ntw.src::Vector{PropDict}\nusers ntw.usr::Vector{PropDict}\ncomponent library ntw.clib::LibDict\nsource library ntw.slib::LibDict\nusers library ntw.ulib::LibDict","category":"page"},{"location":"network/#Constructors","page":"Network","title":"Constructors","text":"","category":"section"},{"location":"network/","page":"Network","title":"Network","text":"One constructor is implemented:","category":"page"},{"location":"network/","page":"Network","title":"Network","text":"MultiStateSystems.Network()","category":"page"},{"location":"network/#MultiStateSystems.Network-Tuple{}","page":"Network","title":"MultiStateSystems.Network","text":"Network()\n\nAn network constructor.\n\nExample\n\njulia> ntw = Network()\n\n\n\n\n\n","category":"method"},{"location":"network/#Info","page":"Network","title":"Info","text":"","category":"section"},{"location":"network/","page":"Network","title":"Network","text":"A number of properties are defined for networks captured by NetworkInfo.","category":"page"},{"location":"network/","page":"Network","title":"Network","text":"solved:   the solved property describes whether the ugf of a network's users have been   determined.\ndependent_source:   the dependent source property flags that the output of all sources in the   network are dependent on an uniform source, e.g., wind turbines in a single   windfarm.","category":"page"},{"location":"network/#Component","page":"Network","title":"Component","text":"","category":"section"},{"location":"network/","page":"Network","title":"Network","text":"Any component (abbr: cmp) is represented by a PropDict mapped onto either the vertices or edges of the multigraph ntw.graph. The collection of all components is stored in ntw.cmp, which is a vector.","category":"page"},{"location":"network/","page":"Network","title":"Network","text":"The link between the component id, i.e., its index in ntw.cmp, and the vertex/edge of ntw.graph to which it is mapped is stored in ntw.clib (key: vertex/edge, value: [cmp...]).","category":"page"},{"location":"network/","page":"Network","title":"Network","text":"Any property may be added to the Propdict representing the component, however certain properties are reserved for specific functionality of the tool, each linked to a specific key [Symbol].","category":"page"},{"location":"network/","page":"Network","title":"Network","text":":node is reserved for the component's node in the multigraph ntw.graph\n:edge is reserved for the component's edge in the multigraph ntw.graph\n:std is reserved for the state-transition diagram of the component","category":"page"},{"location":"network/","page":"Network","title":"Network","text":"note: Note\nIn order to link the specific component to either a vertex or an edge of the network, it is obligatory to provide them through the named argument :node or :edge, respectively.","category":"page"},{"location":"network/","page":"Network","title":"Network","text":"Components may either be added to a network individually or grouped using, respectively:","category":"page"},{"location":"network/","page":"Network","title":"Network","text":"add_component!(ntw::MultiStateSystems.AbstractNetwork; kwargs...)","category":"page"},{"location":"network/#MultiStateSystems.add_component!-Tuple{MultiStateSystems.AbstractNetwork}","page":"Network","title":"MultiStateSystems.add_component!","text":"add_components!(ntw::MultiStateSystems.AbstractNetwork; kwargs...)\n\nAdds a single component to the network ntw and fills their corresponding PropDict with the named arguments kwargs.\n\nExample\n\njulia> ntw·µñ ∑ ≥ = ntw()\njulia> add_components!(ntw·µñ ∑ ≥, edge = (1,2),\n                               name = \"cable 1\",\n                               std  = STD(power = [0u\"MW\",1500u\"MW\"],\n                                          prob  = [0.2,0.8]))\n\n\n\n\n\n","category":"method"},{"location":"network/","page":"Network","title":"Network","text":"add_components!(ntw::MultiStateSystems.AbstractNetwork; kwargs...)","category":"page"},{"location":"network/#MultiStateSystems.add_components!-Tuple{MultiStateSystems.AbstractNetwork}","page":"Network","title":"MultiStateSystems.add_components!","text":"add_components!(ntw::MultiStateSystems.AbstractNetwork; kwargs...)\n\nAdds multiple components to the network ntw and fills their corresponding PropDict with the named arguments kwargs. Either an uniform arguments is given which holds for all components or an array is given whith specific argument for each component.\n\nExample\n\njulia> ntw·µñ ∑ ≥ = ntw()\njulia> add_components!(ntw·µñ ∑ ≥, edge = [(1,2),(1,2),(2,3)],\n                               name = [\"cable 1\",\"cable 2\",\"cable 3\"],\n                               std  = [STD(power = [0u\"MW\",1500u\"MW\"],\n                                           prob  = [0.2,0.8]),\n                                       STD(power = [0u\"MW\",2000u\"MW\"],\n                                           prob  = [0.4,0.6]),\n                                       STD(power = [0u\"MW\",1800u\"MW\",4000u\"MW\"],\n                                           prob = [0.1,0.2,0.7])])\n\n\n\n\n\n","category":"method"},{"location":"network/#Source","page":"Network","title":"Source","text":"","category":"section"},{"location":"network/","page":"Network","title":"Network","text":"Any source (abbr: src) is represented by a PropDict mapped onto either the vertices of the multigraph ntw.graph. The collection of all sources is stored in ntw.src, which is a vector.","category":"page"},{"location":"network/","page":"Network","title":"Network","text":"The link between the source id, i.e., its index in ntw.src, and the vertex of ntw.graph to which it is mapped is stored in ntw.slib (key: vertex, value: [cmp...]).","category":"page"},{"location":"network/","page":"Network","title":"Network","text":"Any property may be added to the Propdict representing the source, however certain properties are reserved for specific functionality of the tool, each linked to a specific key [Symbol].","category":"page"},{"location":"network/","page":"Network","title":"Network","text":":node is reserved for the source's node in the multigraph ntw.graph\n:std is reserved for the state-transition diagram of the source\n:ntw is reserved for the tuple (ntw,usr) representing the source, where usr is the user-id [Int] of the network ntw.\n:dep_source is reserved for the dependent_source property.\n:dep_eval is reserved for the dependent_evaluation property.","category":"page"},{"location":"network/","page":"Network","title":"Network","text":"note: Note\nIn order to link the specific source to a vertex of the network, it is obligatory to provide them through the named argument :node.","category":"page"},{"location":"network/","page":"Network","title":"Network","text":"Sources may either be added to a network individually or grouped using, respectively:","category":"page"},{"location":"network/","page":"Network","title":"Network","text":"add_source!(ntw::MultiStateSystems.AbstractNetwork; kwargs...)","category":"page"},{"location":"network/#MultiStateSystems.add_source!-Tuple{MultiStateSystems.AbstractNetwork}","page":"Network","title":"MultiStateSystems.add_source!","text":"add_source!(ntw::MultiStateSystems.AbstractNetwork; kwargs...)\n\nAdds a single source to the network ntw and fills their corresponding PropDict with the named arguments kwargs.\n\nExample\n\njulia> ntw·µñ ∑ ≥ = ntw()\njulia> std·µç·µâ‚Åø = solvedSTD(prob = [0.1,0.2,0.7],\n                          flow = [0.0u\"MW\",0.5u\"MW\",2.0u\"MW\"])\njulia> add_source!(ntw·µñ ∑ ≥, node = 1,\n                           name = \"generator 1\",\n                           std  = std·µç·µâ‚Åø)\n\n\n\n\n\n","category":"method"},{"location":"network/","page":"Network","title":"Network","text":"add_sources!(ntw::MultiStateSystems.AbstractNetwork; kwargs...)","category":"page"},{"location":"network/#MultiStateSystems.add_sources!-Tuple{MultiStateSystems.AbstractNetwork}","page":"Network","title":"MultiStateSystems.add_sources!","text":"add_sources!(ntw::MultiStateSystems.AbstractNetwork; kwargs...)\n\nAdds multiple sources to the network ntw and fills their corresponding PropDict with the named arguments kwargs. Either an uniform arguments is given which holds for all components or an array is given whith specific argument for each component.\n\nExample\n\njulia> ntw·µñ ∑ ≥ = ntw()\njulia> std·µç·µâ‚Åø = solvedSTD(prob = [0.1,0.2,0.7],\n                          flow = [0.0u\"MW\",0.5u\"MW\",2.0u\"MW\"])\njulia> add_sources!(ntw·µñ ∑ ≥, node = 1:5,\n                            std  = std·µç·µâ‚Åø,\n                            dep  = true)\n\n\n\n\n\n","category":"method"},{"location":"network/#Users","page":"Network","title":"Users","text":"","category":"section"},{"location":"network/","page":"Network","title":"Network","text":"Any user (abbr: usr) is represented by a PropDict mapped onto either the vertices of the multigraph ntw.graph. The collection of all users is stored in ntw.usr, which is a vector.","category":"page"},{"location":"network/","page":"Network","title":"Network","text":"The link between the user id, i.e., its index in ntw.usr, and the vertex of ntw.graph to which it is mapped is stored in ntw.ulib (key: vertex, value: [cmp...]).","category":"page"},{"location":"network/","page":"Network","title":"Network","text":"Any property may be added to the Propdict representing the user, however certain properties are reserved for specific functionality of the tool, each linked to a specific key [Symbol].","category":"page"},{"location":"network/","page":"Network","title":"Network","text":":node is reserved for the user's vertex in the multigraph ntw.graph\n:std is reserved for the state-transition diagram of the user\n:ind is reserved for the user's indices","category":"page"},{"location":"network/","page":"Network","title":"Network","text":"note: Note\nIn order to link the specific user to a vertex of the network, it is obligatory to provide them through the named argument :node.","category":"page"},{"location":"network/","page":"Network","title":"Network","text":"Users may either be added to a network individually or grouped using, respectively:","category":"page"},{"location":"network/","page":"Network","title":"Network","text":"add_user!(ntw::MultiStateSystems.AbstractNetwork; kwargs...)","category":"page"},{"location":"network/#MultiStateSystems.add_user!-Tuple{MultiStateSystems.AbstractNetwork}","page":"Network","title":"MultiStateSystems.add_user!","text":"add_user!(ntw::MultiStateSystems.AbstractNetwork; kwargs...)\n\nAdds a single user to the network ntw and fills their corresponding PropDict with the named arguments kwargs.\n\nExample\n\njulia> ntw·µñ ∑ ≥ = ntw()\njulia> add_source!(ntw·µñ ∑ ≥, node = 1,\n                           ind  = [:EENS])\n\n\n\n\n\n","category":"method"},{"location":"network/","page":"Network","title":"Network","text":"add_users!(ntw::MultiStateSystems.AbstractNetwork; kwargs...)","category":"page"},{"location":"network/#MultiStateSystems.add_users!-Tuple{MultiStateSystems.AbstractNetwork}","page":"Network","title":"MultiStateSystems.add_users!","text":"add_users!(ntw::MultiStateSystems.AbstractNetwork; kwargs...)\n\nAdds multiple users to the network ntw and fills their corresponding PropDict with the named arguments kwargs. Either an uniform arguments is given which holds for all components or an array is given whith specific argument for each component.\n\nExample\n\njulia> ntw·µñ ∑ ≥ = ntw()\njulia> add_sources!(ntw·µñ ∑ ≥, node = [1,5,8],\n                            ind  = [:EENS])\n\n\n\n\n\n","category":"method"}]
}
