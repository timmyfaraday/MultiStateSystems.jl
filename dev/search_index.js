var documenterSearchIndex = {"docs":
[{"location":"ugf/#Universal-Generating-Function-1","page":"Generating Functions","title":"Universal Generating Function","text":"","category":"section"},{"location":"ugf/#Introduction-1","page":"Generating Functions","title":"Introduction","text":"","category":"section"},{"location":"ugf/#","page":"Generating Functions","title":"Generating Functions","text":"An universal generating function (abbr: ugf) approach approach enables the combination of components and sources to evaluate their performance with respect to a network's users.","category":"page"},{"location":"ugf/#","page":"Generating Functions","title":"Generating Functions","text":"An universal generator function Ï‰_x(z) of a component/source x combines the probabilities p and associated values v of a specific measure m in one polynomial expression:","category":"page"},{"location":"ugf/#","page":"Generating Functions","title":"Generating Functions","text":"    Ï‰_x(z) = sum_o in mathcalO p_o cdot z^v_o","category":"page"},{"location":"ugf/#","page":"Generating Functions","title":"Generating Functions","text":"where ð“ž is the reduced state-space which only contains unique values for a specific measure.","category":"page"},{"location":"ugf/#Constructors-1","page":"Generating Functions","title":"Constructors","text":"","category":"section"},{"location":"ugf/#","page":"Generating Functions","title":"Generating Functions","text":"Two constructors are implemented:","category":"page"},{"location":"ugf/#","page":"Generating Functions","title":"Generating Functions","text":"MultiStateSystems.UGF(msr::Symbol, prb::Vector, val::Vector)","category":"page"},{"location":"ugf/#MultiStateSystems.UGF-Tuple{Symbol,Array{T,1} where T,Array{T,1} where T}","page":"Generating Functions","title":"MultiStateSystems.UGF","text":"UGF(msr::Symbol, prb::Vector, val::Vector)\n\nA UGF constructor for a specific measure msr based on a given probability vector prb and value vector val.\n\nThis function automatically reduces the state-space to where only unique values and associated probabilites remain.\n\nExample\n\njulia> ugfáµáµ‰â¿ = UGF(:flow, [0.1,0.2,0.7], [0.0u\"MW\",0.0u\"MW\",2.0u\"MW\"])\njulia> isequal(ugfáµáµ‰â¿,[0.0u\"MW\",2.0u\"MW\"])\ntrue\n\n\n\n\n\n","category":"method"},{"location":"ugf/#","page":"Generating Functions","title":"Generating Functions","text":"MultiStateSystems.UGF(msr::Symbol, std::MultiStateSystems.AbstractSTD)","category":"page"},{"location":"ugf/#MultiStateSystems.UGF-Tuple{Symbol,MultiStateSystems.AbstractSTD}","page":"Generating Functions","title":"MultiStateSystems.UGF","text":"UGF(msr::Symbol, std::MultiStateSystems.AbstractSTD)\n\nA UGF constructor for a specific measure msr based on a given state-transition diagram std.\n\nThis function automatically reduces the state-space to where only unique values and associated probabilites remain.\n\nExample\n\njulia> stdáµáµ‰â¿ = STD(prob = [0.1,0.2,0.7],\n                    flow = [0.0u\"MW\",0.0u\"MW\",2.0u\"MW\"])\njulia> ugfáµáµ‰â¿ = UGF(:flow, stdáµáµ‰â¿)\njulia> isequal(ugfáµáµ‰â¿,[0.0u\"MW\",2.0u\"MW\"])\ntrue\n\n\n\n\n\n","category":"method"},{"location":"std/#State-Transition-Diagram-1","page":"State-Transition Diagram","title":"State-Transition Diagram","text":"","category":"section"},{"location":"std/#Quick-Links-1","page":"State-Transition Diagram","title":"Quick Links","text":"","category":"section"},{"location":"std/#","page":"State-Transition Diagram","title":"State-Transition Diagram","text":"Pages = [\"std.md\"]","category":"page"},{"location":"std/#Introduction-1","page":"State-Transition Diagram","title":"Introduction","text":"","category":"section"},{"location":"std/#","page":"State-Transition Diagram","title":"State-Transition Diagram","text":"In its essence, a state-transition diagram (abbr: std) is a collections of states and transitions mapped onto a directed graph through metadata on its vertices and edges, respectively.","category":"page"},{"location":"std/#","page":"State-Transition Diagram","title":"State-Transition Diagram","text":"Any state-transition diagram has four attributes:","category":"page"},{"location":"std/#","page":"State-Transition Diagram","title":"State-Transition Diagram","text":"a directed graph std.graph::SimpleDiGraph\nstate-transition diagram properties std.props::PropDict\nstate properties std.sprops::Dict{Int,PropDict}\ntransition properties std.tprops::Dict{Edge,PropDict}","category":"page"},{"location":"std/#Constructors-1","page":"State-Transition Diagram","title":"Constructors","text":"","category":"section"},{"location":"std/#","page":"State-Transition Diagram","title":"State-Transition Diagram","text":"Two constructors are implemented:","category":"page"},{"location":"std/#","page":"State-Transition Diagram","title":"State-Transition Diagram","text":"MultiStateSystems.STD()","category":"page"},{"location":"std/#MultiStateSystems.STD-Tuple{}","page":"State-Transition Diagram","title":"MultiStateSystems.STD","text":"STD()\n\nAn empty state-transition diagram constructor.\n\nExample\n\njulia> stdáµáµ‰â¿ = STD()\n\n\n\n\n\n","category":"method"},{"location":"std/#","page":"State-Transition Diagram","title":"State-Transition Diagram","text":"MultiStateSystems.STD(;prob::Array, kwargs...)","category":"page"},{"location":"std/#Info-1","page":"State-Transition Diagram","title":"Info","text":"","category":"section"},{"location":"std/#","page":"State-Transition Diagram","title":"State-Transition Diagram","text":"A number of properties are defined for state-transition diagrams, states and transitions, respectively captured by (a) STDInfo, (b) StateInfo and (c) TransInfo.","category":"page"},{"location":"std/#","page":"State-Transition Diagram","title":"State-Transition Diagram","text":"markovian [(a),(c)]:   the Markov property refers   to the memoryless property of a stochastic process. It entails that the   conditional probability distribution of future states only depends on the   present state, including calendar time, however, they are independent of the   present state's sojourn time (see: strong Markov property).\nrenewal [(a), (b), (c)]:   the renewal property entails that the stochastic process probabilistically start   over at each arrival epoch. Consequently, a non-renewal transition entails that   its to-state is not necessarily entered with a zero sojourn time.\ntime_homogeneous [(a), (c)]:   the time-homogeneous property   entails that the transition probability between two given states at any two   times depends only on the difference between those times\ntrapping [(b)]:   the trapping property entails that a state is only partially/never exited upon   entering.\nsolved [(a)]:   the solved property describes whether the state probabilities of a   state-transition diagram have been determined.","category":"page"},{"location":"std/#State-1","page":"State-Transition Diagram","title":"State","text":"","category":"section"},{"location":"std/#","page":"State-Transition Diagram","title":"State-Transition Diagram","text":"Any state is represented by a PropDict mapped onto the vertices of the directed graph std.graph. The collection of all states is stored in std.sprops which is a dictionary indexed using the vertex ids [Int].","category":"page"},{"location":"std/#","page":"State-Transition Diagram","title":"State-Transition Diagram","text":"Any property may be added the PropDict representing a state, however certain properties are reserved for specific functionality of the tool, each linked to a specific key [Symbol].","category":"page"},{"location":"std/#","page":"State-Transition Diagram","title":"State-Transition Diagram","text":":info is reserved for the StateInfo\n:init is reserved for the initial state probability p(0) [-]\n:prob is reserved for the state probability p(t) [-]\n:flow is reserved for the state flow measure [mÂ³/hr]\n:power is reserved for the state power measure [MW]","category":"page"},{"location":"std/#","page":"State-Transition Diagram","title":"State-Transition Diagram","text":"States may either be added to state-transition diagram individually or grouped using, respectively:","category":"page"},{"location":"std/#","page":"State-Transition Diagram","title":"State-Transition Diagram","text":"MultiStateSystems.add_state!(std::MultiStateSystems.AbstractSTD; kwargs...)","category":"page"},{"location":"std/#MultiStateSystems.add_state!-Tuple{MultiStateSystems.AbstractSTD}","page":"State-Transition Diagram","title":"MultiStateSystems.add_state!","text":"add_state!(std::MultiStateSystems.AbstractSTD; kwargs...)\n\nAdds a single state to the state-transition diagram std and fills its corresponding PropDict with the named arguments kwargs.\n\nExample\n\njulia> stdáµáµ‰â¿ = STD()\njulia> add_state!(stdáµáµ‰â¿, name  = \"normal operation state\",\n                          power = 100u\"MW\",\n                          init  = 1.0)\n\n\n\n\n\n","category":"method"},{"location":"std/#","page":"State-Transition Diagram","title":"State-Transition Diagram","text":"MultiStateSystems.add_states!(std::MultiStateSystems.AbstractSTD; kwargs...)","category":"page"},{"location":"std/#MultiStateSystems.add_states!-Tuple{MultiStateSystems.AbstractSTD}","page":"State-Transition Diagram","title":"MultiStateSystems.add_states!","text":"add_states!(std::MultiStateSystems.AbstractSTD; kwargs...)\n\nAdds multiple states to the state-transition diagram std and fills their corresponding PropDict with the named arguments kwargs. Either an uniform argument is given which holds for all states or an array is given with the specific argument for each state.\n\nExample\n\njulia> stdáµáµ‰â¿ = STD()\njulia> add_states!(stdáµáµ‰â¿, name  = [\"normal operation state\",\"failed state\"],\n                           power = [100.0u\"MW\",0.0u\"MW\"],\n                           init  = [1.0,0.0],\n                           markovian = true)\n\n\n\n\n\n","category":"method"},{"location":"std/#Transition-1","page":"State-Transition Diagram","title":"Transition","text":"","category":"section"},{"location":"std/#","page":"State-Transition Diagram","title":"State-Transition Diagram","text":"Any transition is represented by a PropDict mapped onto the edges of the directed graph std.graph. The collection of all transitions is stored in std.tprops which is a dictionary indexed using the edge ids [Edge].","category":"page"},{"location":"std/#","page":"State-Transition Diagram","title":"State-Transition Diagram","text":"Any property may be added to the PropDict representing a transition, however certain properties are reserved for specific functionality of the tool, each linked to a specific key [Symbol].","category":"page"},{"location":"std/#","page":"State-Transition Diagram","title":"State-Transition Diagram","text":":states is reserved for the tuple (fr,to) of the from- and to-state\n:rate is reserved for the transition rate rho(tÏ†) [1/hr]","category":"page"},{"location":"std/#","page":"State-Transition Diagram","title":"State-Transition Diagram","text":"Transitions may either be added to a state-transition diagram individually or grouped using, respectively:","category":"page"},{"location":"std/#","page":"State-Transition Diagram","title":"State-Transition Diagram","text":"MultiStateSystems.add_transition!(std::MultiStateSystems.AbstractSTD; kwargs...)","category":"page"},{"location":"std/#MultiStateSystems.add_transition!-Tuple{MultiStateSystems.AbstractSTD}","page":"State-Transition Diagram","title":"MultiStateSystems.add_transition!","text":"add_transition!(std::MultiStateSystems.AbstractSTD; kwargs...)\n\nAdds a single transitions to the state-transition diagram std and fills its corresponding PropDict with the named arguments kwargs. One obligatory named argument is :states, describing the tuple (fr,to) of the from- and to-state.\n\nExample\n\njulia> stdáµáµ‰â¿ = STD()\njulia> add_states!(stdáµáµ‰â¿, name  = [\"normal operation state\",\"failed state\"],\n                           power = [100.0u\"MW\",0.0u\"MW\"],\n                           init  = [1.0,0.0],\n                           markovian = true)\njulia> add_transition!(stdáµáµ‰â¿, rate = 0.001u\"1/hr\",\n                               states = (1,2))\n\n\n\n\n\n","category":"method"},{"location":"std/#","page":"State-Transition Diagram","title":"State-Transition Diagram","text":"MultiStateSystems.add_transitions!(std::MultiStateSystems.AbstractSTD; kwargs...)","category":"page"},{"location":"std/#MultiStateSystems.add_transitions!-Tuple{MultiStateSystems.AbstractSTD}","page":"State-Transition Diagram","title":"MultiStateSystems.add_transitions!","text":"add_transitions!(std::MultiStateSystems.AbstractSTD; kwargs...)\n\nAdds multiple transitions to the state-transition diagram std and fills their corresponding PropDict with the named arguments kwargs. Either an uniform argument is given which holds for all transitions or an array is given with the specific argument for each transition.\n\nExample\n\njulia> stdáµáµ‰â¿ = STD()\njulia> add_states!(stdáµáµ‰â¿, name  = [\"normal operation state\",\"failed state\"],\n                           power = [100.0u\"MW\",0.0u\"MW\"],\n                           init  = [1.0,0.0],\n                           markovian = true)\njulia> add_transitions!(stdáµáµ‰â¿, rate = [0.001u\"1/hr\",0.01u\"1/hr\"],\n                                states = [(1,2),(2,1)])\n\nnote: Note\nIf the :states argument is not provided in the add_transitions! function, the from- and to-states will be determined based on the other arguments.\n\nExample (Alternative)\n\njulia> add_transitions!(stdáµáµ‰â¿, rate = [0.000u\"1/hr\" 0.010u\"1/hr\"\n                                        0.001u\"1/hr\" 0.000u\"1/hr\"])\n\n\n\n\n\n","category":"method"},{"location":"ugo/#Universal-Generating-Operator-1","page":"Generating Operators","title":"Universal Generating Operator","text":"","category":"section"},{"location":"ugo/#Introduction-1","page":"Generating Operators","title":"Introduction","text":"","category":"section"},{"location":"ugo/#","page":"Generating Operators","title":"Generating Operators","text":"Solving a network ntw through the univeral generating operator may be accomplished through:","category":"page"},{"location":"ugo/#","page":"Generating Operators","title":"Generating Operators","text":"solve!(ntw::MultiStateSystems.AbstractNetwork; type::Symbol=:steady)","category":"page"},{"location":"ugo/#MultiStateSystems.solve!-Tuple{MultiStateSystems.AbstractNetwork}","page":"Generating Operators","title":"MultiStateSystems.solve!","text":"solve!(ntw::MultiStateSystems.AbstractNetwork; type::Symbol=:steady)\n\nThis function determines the universal generating function related to the output of all users usr of a network ntw.\n\nOptionally, the type\n\n\n\n\n\n","category":"method"},{"location":"processes/#Stochastic-Processes-1","page":"Stochastic Processes","title":"Stochastic Processes","text":"","category":"section"},{"location":"processes/#Introduction-1","page":"Stochastic Processes","title":"Introduction","text":"","category":"section"},{"location":"processes/#","page":"Stochastic Processes","title":"Stochastic Processes","text":"A number of stochastic processes are available to determine the state probabilities of an std:","category":"page"},{"location":"processes/#","page":"Stochastic Processes","title":"Stochastic Processes","text":"Markov chain :markov_chain\nMarkov process :markov_process\nSemi-Markov process :semimarkov\nVan Acker process :vanacker","category":"page"},{"location":"processes/#","page":"Stochastic Processes","title":"Stochastic Processes","text":"Solving a stochastic process may be accomplished through:","category":"page"},{"location":"processes/#","page":"Stochastic Processes","title":"Stochastic Processes","text":"solve!(std::MultiStateSystems.AbstractSTD, tsim::Number; alg::Symbol=:nothing)","category":"page"},{"location":"processes/#MultiStateSystems.solve!-Tuple{MultiStateSystems.AbstractSTD,Number}","page":"Stochastic Processes","title":"MultiStateSystems.solve!","text":"solve!(std::MultiStateSystems.AbstractSTD, tsim::Number; alg::Symbol=:nothing)\n\nThis function determines the state probabilities of the state-transition diagram std for a given simulation horizon tsim.\n\nOptionally, the prefered stochastic process may be provided through the named argument alg, otherwise the appropriate stochastic process is determined using the properties of the state-transition diagram.\n\nExample\n\njulia> solve!(stdáµáµ‰â¿, 1000u\"hr\", alg = :markov_process)\n\n\n\n\n\n","category":"method"},{"location":"processes/#Markov-Process-1","page":"Stochastic Processes","title":"Markov Process","text":"","category":"section"},{"location":"processes/#","page":"Stochastic Processes","title":"Stochastic Processes","text":"Spaces  Properties \nState-space discrete Renewal âœ…\nTime-space continuous Markov âœ…","category":"page"},{"location":"processes/#","page":"Stochastic Processes","title":"Stochastic Processes","text":"A Markov process is described by a random variable X_t, where t denotes the calendar time. The possible values of X_t are represented by the discrete state-space ð“¢ of the state transition diagram std.","category":"page"},{"location":"processes/#","page":"Stochastic Processes","title":"Stochastic Processes","text":"A Markov process respects the Markov property, which means it respects","category":"page"},{"location":"processes/#","page":"Stochastic Processes","title":"Stochastic Processes","text":"â„™(X_t  ð“¢  ð“•_s) = â„™(X_t  ð“¢  X_s)  st  ð•€ s  t","category":"page"},{"location":"processes/#","page":"Stochastic Processes","title":"Stochastic Processes","text":"where ð“•_s represents a filtration of a probability space (Î©,ð“•,â„™) and ð•€ a totally ordered index set. A Markov process is described by Kolmogorov equations, more specifically the Kolmogorov forward equations:","category":"page"},{"location":"processes/#","page":"Stochastic Processes","title":"Stochastic Processes","text":" Î´p_ij(st)Î´t = _k p_ik(st)  A_kj(t)  ij  ð“¢ st  ð•€ s  t","category":"page"},{"location":"processes/#","page":"Stochastic Processes","title":"Stochastic Processes","text":"where A(t) represents the transition matrix, syn., generator matrix. The latter may be translated into an initial value problem for finding the state probabilities, given transition rates Ï_ij(t) and initial values Î´_i:","category":"page"},{"location":"processes/#","page":"Stochastic Processes","title":"Stochastic Processes","text":"dp_i(t)dt = - _j Ï_ij(t)p_i(t) + _j Ï_ji(t)p_j(t)   i  ð“¢","category":"page"},{"location":"#MultiStateSystems.jl-1","page":"Home","title":"MultiStateSystems.jl","text":"","category":"section"},{"location":"#Overview-1","page":"Home","title":"Overview","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"MultiStateSystems.jl is a Julia package to solve multi-state systems, often found in reliability engineering.","category":"page"},{"location":"#Installation-1","page":"Home","title":"Installation","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"The latest stable release of MultiStateSystems can be installed using the Julia package manager:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"] add https://github.com/timmyfaraday/MultiStateSystems.jl.git","category":"page"},{"location":"#","page":"Home","title":"Home","text":"In order to test whether the package works, run:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"] test MultiStateSystems","category":"page"},{"location":"network/#Network-1","page":"Network","title":"Network","text":"","category":"section"},{"location":"network/#Quick-Links-1","page":"Network","title":"Quick Links","text":"","category":"section"},{"location":"network/#","page":"Network","title":"Network","text":"Pages = [\"network.md\"]","category":"page"},{"location":"network/#Introduction-1","page":"Network","title":"Introduction","text":"","category":"section"},{"location":"network/#","page":"Network","title":"Network","text":"In its essence, a network (abbr: ntw) is a collection of sources, components and users mapped onto a multigraph.","category":"page"},{"location":"network/#","page":"Network","title":"Network","text":"Any network has eight attributes:","category":"page"},{"location":"network/#","page":"Network","title":"Network","text":"a multigraph ntw.graph::Multigraph\nnetwork properties ntw.props::PropDict\ncomponents ntw.cmp::Vector{PropDict}\nsources ntw.src::Vector{PropDict}\nusers ntw.usr::Vector{PropDict}\ncomponent library ntw.clib::LibDict\nsource library ntw.slib::LibDict\nusers library ntw.ulib::LibDict","category":"page"},{"location":"network/#Constructors-1","page":"Network","title":"Constructors","text":"","category":"section"},{"location":"network/#","page":"Network","title":"Network","text":"One constructor is implemented:","category":"page"},{"location":"network/#","page":"Network","title":"Network","text":"MultiStateSystems.Network()","category":"page"},{"location":"network/#MultiStateSystems.Network-Tuple{}","page":"Network","title":"MultiStateSystems.Network","text":"Network()\n\nAn network constructor.\n\nExample\n\njulia> ntw = Network()\n\n\n\n\n\n","category":"method"},{"location":"network/#Info-1","page":"Network","title":"Info","text":"","category":"section"},{"location":"network/#","page":"Network","title":"Network","text":"A number of properties are defined for networks captured by NetworkInfo.","category":"page"},{"location":"network/#","page":"Network","title":"Network","text":"solved:   the solved property describes whether the ugf of a network's users have been   determined.\ndependent_source:   the dependent source property flags that the output of all sources in the   network are dependent on an uniform source, e.g., wind turbines in a single   windfarm.","category":"page"},{"location":"network/#Component-1","page":"Network","title":"Component","text":"","category":"section"},{"location":"network/#","page":"Network","title":"Network","text":"Any component (abbr: cmp) is represented by a PropDict mapped onto either the vertices or edges of the multigraph ntw.graph. The collection of all components is stored in ntw.cmp, which is a vector.","category":"page"},{"location":"network/#","page":"Network","title":"Network","text":"The link between the component id, i.e., its index in ntw.cmp, and the vertex/edge of ntw.graph to which it is mapped is stored in ntw.clib (key: vertex/edge, value: [cmp...]).","category":"page"},{"location":"network/#","page":"Network","title":"Network","text":"Any property may be added to the Propdict representing the component, however certain properties are reserved for specific functionality of the tool, each linked to a specific key [Symbol].","category":"page"},{"location":"network/#","page":"Network","title":"Network","text":":node is reserved for the component's node in the multigraph ntw.graph\n:edge is reserved for the component's edge in the multigraph ntw.graph\n:std is reserved for the state-transition diagram of the component","category":"page"},{"location":"network/#","page":"Network","title":"Network","text":"note: Note\nIn order to link the specific component to either a vertex or an edge of the network, it is obligatory to provide them through the named argument :node or :edge, respectively.","category":"page"},{"location":"network/#","page":"Network","title":"Network","text":"Components may either be added to a network individually or grouped using, respectively:","category":"page"},{"location":"network/#","page":"Network","title":"Network","text":"add_component!(ntw::MultiStateSystems.AbstractNetwork; kwargs...)","category":"page"},{"location":"network/#MultiStateSystems.add_component!-Tuple{MultiStateSystems.AbstractNetwork}","page":"Network","title":"MultiStateSystems.add_component!","text":"add_components!(ntw::MultiStateSystems.AbstractNetwork; kwargs...)\n\nAdds a single component to the network ntw and fills their corresponding PropDict with the named arguments kwargs.\n\nExample\n\njulia> ntwáµ–Ê·Ê³ = ntw()\njulia> add_components!(ntwáµ–Ê·Ê³, edge = (1,2),\n                               name = \"cable 1\",\n                               std  = STD(power = [0u\"MW\",1500u\"MW\"],\n                                          prob  = [0.2,0.8]))\n\n\n\n\n\n","category":"method"},{"location":"network/#","page":"Network","title":"Network","text":"add_components!(ntw::MultiStateSystems.AbstractNetwork; kwargs...)","category":"page"},{"location":"network/#MultiStateSystems.add_components!-Tuple{MultiStateSystems.AbstractNetwork}","page":"Network","title":"MultiStateSystems.add_components!","text":"add_components!(ntw::MultiStateSystems.AbstractNetwork; kwargs...)\n\nAdds multiple components to the network ntw and fills their corresponding PropDict with the named arguments kwargs. Either an uniform arguments is given which holds for all components or an array is given whith specific argument for each component.\n\nExample\n\njulia> ntwáµ–Ê·Ê³ = ntw()\njulia> add_components!(ntwáµ–Ê·Ê³, edge = [(1,2),(1,2),(2,3)],\n                               name = [\"cable 1\",\"cable 2\",\"cable 3\"],\n                               std  = [STD(power = [0u\"MW\",1500u\"MW\"],\n                                           prob  = [0.2,0.8]),\n                                       STD(power = [0u\"MW\",2000u\"MW\"],\n                                           prob  = [0.4,0.6]),\n                                       STD(power = [0u\"MW\",1800u\"MW\",4000u\"MW\"],\n                                           prob = [0.1,0.2,0.7])])\n\n\n\n\n\n","category":"method"},{"location":"network/#Source-1","page":"Network","title":"Source","text":"","category":"section"},{"location":"network/#","page":"Network","title":"Network","text":"Any source (abbr: src) is represented by a PropDict mapped onto either the vertices of the multigraph ntw.graph. The collection of all sources is stored in ntw.src, which is a vector.","category":"page"},{"location":"network/#","page":"Network","title":"Network","text":"The link between the source id, i.e., its index in ntw.src, and the vertex of ntw.graph to which it is mapped is stored in ntw.slib (key: vertex, value: [cmp...]).","category":"page"},{"location":"network/#","page":"Network","title":"Network","text":"Any property may be added to the Propdict representing the source, however certain properties are reserved for specific functionality of the tool, each linked to a specific key [Symbol].","category":"page"},{"location":"network/#","page":"Network","title":"Network","text":":node is reserved for the source's node in the multigraph ntw.graph\n:std is reserved for the state-transition diagram of the source\n:ntw is reserved for the tuple (ntw,usr) representing the source, where usr","category":"page"},{"location":"network/#","page":"Network","title":"Network","text":"is the user-id [Int] of the network ntw.","category":"page"},{"location":"network/#","page":"Network","title":"Network","text":":dep is reserved for the dependent_source property.","category":"page"},{"location":"network/#","page":"Network","title":"Network","text":"note: Note\nIn order to link the specific source to a vertex of the network, it is obligatory to provide them through the named argument :node.","category":"page"},{"location":"network/#","page":"Network","title":"Network","text":"Sources may either be added to a network individually or grouped using, respectively:","category":"page"},{"location":"network/#","page":"Network","title":"Network","text":"add_source!(ntw::MultiStateSystems.AbstractNetwork; kwargs...)","category":"page"},{"location":"network/#MultiStateSystems.add_source!-Tuple{MultiStateSystems.AbstractNetwork}","page":"Network","title":"MultiStateSystems.add_source!","text":"add_source!(ntw::MultiStateSystems.AbstractNetwork; kwargs...)\n\nAdds a single source to the network ntw and fills their corresponding PropDict with the named arguments kwargs.\n\nExample\n\njulia> ntwáµ–Ê·Ê³ = ntw()\njulia> stdáµáµ‰â¿ = STD(prob = [0.1,0.2,0.7],\n                    flow = [0.0u\"MW\",0.5u\"MW\",2.0u\"MW\"])\njulia> add_source!(ntwáµ–Ê·Ê³, node = 1,\n                           name = \"generator 1\",\n                           std  = stdáµáµ‰â¿)\n\n\n\n\n\n","category":"method"},{"location":"network/#","page":"Network","title":"Network","text":"add_sources!(ntw::MultiStateSystems.AbstractNetwork; kwargs...)","category":"page"},{"location":"network/#MultiStateSystems.add_sources!-Tuple{MultiStateSystems.AbstractNetwork}","page":"Network","title":"MultiStateSystems.add_sources!","text":"add_sources!(ntw::MultiStateSystems.AbstractNetwork; kwargs...)\n\nAdds multiple sources to the network ntw and fills their corresponding PropDict with the named arguments kwargs. Either an uniform arguments is given which holds for all components or an array is given whith specific argument for each component.\n\nExample\n\njulia> ntwáµ–Ê·Ê³ = ntw()\njulia> stdáµáµ‰â¿ = STD(prob = [0.1,0.2,0.7],\n                    flow = [0.0u\"MW\",0.5u\"MW\",2.0u\"MW\"])\njulia> add_sources!(ntwáµ–Ê·Ê³, node = 1:5,\n                            std  = stdáµáµ‰â¿,\n                            dep  = true)\n\n\n\n\n\n","category":"method"},{"location":"network/#Users-1","page":"Network","title":"Users","text":"","category":"section"},{"location":"network/#","page":"Network","title":"Network","text":"Any user (abbr: usr) is represented by a PropDict mapped onto either the vertices of the multigraph ntw.graph. The collection of all users is stored in ntw.usr, which is a vector.","category":"page"},{"location":"network/#","page":"Network","title":"Network","text":"The link between the user id, i.e., its index in ntw.usr, and the vertex of ntw.graph to which it is mapped is stored in ntw.ulib (key: vertex, value: [cmp...]).","category":"page"},{"location":"network/#","page":"Network","title":"Network","text":"Any property may be added to the Propdict representing the user, however certain properties are reserved for specific functionality of the tool, each linked to a specific key [Symbol].","category":"page"},{"location":"network/#","page":"Network","title":"Network","text":":node is reserved for the user's vertex in the multigraph ntw.graph\n:std is reserved for the state-transition diagram of the user\n:ind is reserved for the user's indices","category":"page"},{"location":"network/#","page":"Network","title":"Network","text":"note: Note\nIn order to link the specific user to a vertex of the network, it is obligatory to provide them through the named argument :node.","category":"page"},{"location":"network/#","page":"Network","title":"Network","text":"Users may either be added to a network individually or grouped using, respectively:","category":"page"},{"location":"network/#","page":"Network","title":"Network","text":"add_user!(ntw::MultiStateSystems.AbstractNetwork; kwargs...)","category":"page"},{"location":"network/#MultiStateSystems.add_user!-Tuple{MultiStateSystems.AbstractNetwork}","page":"Network","title":"MultiStateSystems.add_user!","text":"add_user!(ntw::MultiStateSystems.AbstractNetwork; kwargs...)\n\nAdds a single user to the network ntw and fills their corresponding PropDict with the named arguments kwargs.\n\nExample\n\njulia> ntwáµ–Ê·Ê³ = ntw()\njulia> add_source!(ntwáµ–Ê·Ê³, node = 1,\n                           name = \"Tom's house\",\n                           ind  = [:EENS])\n\n\n\n\n\n","category":"method"},{"location":"network/#","page":"Network","title":"Network","text":"add_users!(ntw::MultiStateSystems.AbstractNetwork; kwargs...)","category":"page"},{"location":"network/#MultiStateSystems.add_users!-Tuple{MultiStateSystems.AbstractNetwork}","page":"Network","title":"MultiStateSystems.add_users!","text":"add_users!(ntw::MultiStateSystems.AbstractNetwork; kwargs...)\n\nAdds multiple users to the network ntw and fills their corresponding PropDict with the named arguments kwargs. Either an uniform arguments is given which holds for all components or an array is given whith specific argument for each component.\n\nExample\n\njulia> ntwáµ–Ê·Ê³ = ntw()\njulia> add_sources!(ntwáµ–Ê·Ê³, node = [1,5,8],\n                            ind  = [:EENS])\n\n\n\n\n\n","category":"method"}]
}
