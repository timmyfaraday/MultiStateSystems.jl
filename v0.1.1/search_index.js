var documenterSearchIndex = {"docs":
[{"location":"distribution/#Distributions-1","page":"Distributions","title":"Distributions","text":"","category":"section"},{"location":"distribution/#Introduction-1","page":"Distributions","title":"Introduction","text":"","category":"section"},{"location":"distribution/#","page":"Distributions","title":"Distributions","text":"The package includes a collection of probabilistic distributions and related functions. The implementation is heavily influenced by the package Distributions.jl, but extends it to allow for weighted distributions as well as the Unitful.jl parameters.","category":"page"},{"location":"distribution/#Distributions-2","page":"Distributions","title":"Distributions","text":"","category":"section"},{"location":"distribution/#","page":"Distributions","title":"Distributions","text":"Each distribution has a number of constructors, both based on its full name and abbreviation, e.g., Weibull() is equivalent to ùëæ(). Furthermore, additional constructors are included for limited input, where all remaining parameters are set to their default, e.g., Weibull(10.0u\"hr\") is equivalent to Weibull(10.0u\"hr\",1.0,1.0).","category":"page"},{"location":"distribution/#","page":"Distributions","title":"Distributions","text":"All input parameters are either of the type Number or its subtype Real:","category":"page"},{"location":"distribution/#","page":"Distributions","title":"Distributions","text":"Number\n |- Unitful.Quantity, e.g., 10.0u\"hr\"\n |- Real\n     |- AbstractFloat, e.g., 10.0\n     |- Integer, e.g., 10","category":"page"},{"location":"distribution/#","page":"Distributions","title":"Distributions","text":"All distributions may be scaled using a weight parameter œâ, where 0.0 < œâ ‚â§ 1.0.","category":"page"},{"location":"distribution/#Dirac-Distribution-1","page":"Distributions","title":"Dirac Distribution","text":"","category":"section"},{"location":"distribution/#","page":"Distributions","title":"Distributions","text":"Dirac","category":"page"},{"location":"distribution/#Uniform-Distribution-1","page":"Distributions","title":"Uniform Distribution","text":"","category":"section"},{"location":"distribution/#","page":"Distributions","title":"Distributions","text":"Uniform","category":"page"},{"location":"distribution/#Exponential-Distribution-1","page":"Distributions","title":"Exponential Distribution","text":"","category":"section"},{"location":"distribution/#","page":"Distributions","title":"Distributions","text":"Exponential","category":"page"},{"location":"distribution/#Weibull-Distribution-1","page":"Distributions","title":"Weibull Distribution","text":"","category":"section"},{"location":"distribution/#","page":"Distributions","title":"Distributions","text":"Weibull","category":"page"},{"location":"distribution/#Raised-Cosine-Distribution-1","page":"Distributions","title":"Raised Cosine Distribution","text":"","category":"section"},{"location":"distribution/#","page":"Distributions","title":"Distributions","text":"Cosine","category":"page"},{"location":"distribution/#MultiStateSystems.Cosine","page":"Distributions","title":"MultiStateSystems.Cosine","text":"Cosine\n\nThe raised cosine distribution with mean Œº [Number], maximal deviation s [Number] and optional weight œâ [Real] has a probability density function\n\nf(x Œº œÉ œâ) = begincases\n                    0                                                                  textifx  Œº-s        \n                    fracœâ2s big(1 + œÄ cosbig(fracx - Œºsbig)ig)   textifŒº-s  x  Œº+s  \n                    0                                                                  textifx  Œº+s\n                endcases\n\nConstructors\n\nFull Abbr. Description\nCosine(Œº,s,œâ) ùë™(Œº,s,œâ) full constructor\nCosine(Œº,s) ùë™(Œº,s) constructor which defaults to Cosine(Œº,s,1.0)\nCosine(Œº) ùë™(Œº) constructor which defaults to Cosine(Œº,1.0,1.0)\nCosine() ùë™() empty constructor which defaults to Cosine(1.0,1.0,1.0)\n\nExamples\n\njulia> Cosine()             # default Raised Cosine distr. with Œº = 1.0, s = 1.0 and œâ = 1.0\njulia> ùë™(3.0u\"minute\")      # Raised Cosine distr. with Œº = 3.0 min, s = 1.0 min and œâ = 1.0\njulia> ùë™(5.0u\"yr\",4.0u\"d\")  # Raised Cosine distr. with Œº = 5.0 yr, s = 4.0 d and œâ = 1.0\njulia> ùë™(10.0,0.5,0.2)      # scaled Raised Cosine distr. with Œº = 10.0, œÉ = 0.5 and œâ = 0.2\n\n\n\n\n\n","category":"type"},{"location":"distribution/#LogNormal-Distribution-1","page":"Distributions","title":"LogNormal Distribution","text":"","category":"section"},{"location":"distribution/#","page":"Distributions","title":"Distributions","text":"LogNormal","category":"page"},{"location":"ugf/#Universal-Generating-Function-1","page":"Generating Functions","title":"Universal Generating Function","text":"","category":"section"},{"location":"ugf/#Introduction-1","page":"Generating Functions","title":"Introduction","text":"","category":"section"},{"location":"ugf/#","page":"Generating Functions","title":"Generating Functions","text":"An universal generating function (abbr: ugf) approach approach enables the combination of components and sources to evaluate their performance with respect to a network's users.","category":"page"},{"location":"ugf/#","page":"Generating Functions","title":"Generating Functions","text":"An universal generator function œâ_x(z) of a component/source x combines the probabilities p and associated values v of a specific measure m in one polynomial expression:","category":"page"},{"location":"ugf/#","page":"Generating Functions","title":"Generating Functions","text":"    œâ_x(z) = sum_o in mathcalO p_o cdot z^v_o","category":"page"},{"location":"ugf/#","page":"Generating Functions","title":"Generating Functions","text":"where ùìû is the reduced state-space which only contains unique values for a specific measure.","category":"page"},{"location":"ugf/#","page":"Generating Functions","title":"Generating Functions","text":"MultiStateSystems.UGF","category":"page"},{"location":"ugf/#MultiStateSystems.UGF","page":"Generating Functions","title":"MultiStateSystems.UGF","text":"UGF\n\nAn ugf is a struct containing: a measure msr, corresponding values val and  associated probabilities prb, with default constructor: \n\nUGF(msr::Symbol, val::Vector, prb::Vector; red::Bool=true)\n\nA UGF constructor for a specific measure msr based on a given value vector  val and associated probability vector prb.\n\nThis function automatically reduces the state-space to where only unique values and associated probabilites remain. This behavior is circumvented by passing the optional argument rdc=false.\n\nExample\n\njulia> ugf·µç·µâ‚Åø = UGF(:power, [0.0u\"MW\",0.0u\"MW\",2.0u\"MW\"], [0.1,0.2,0.7])\njulia> isequal(ugf·µç·µâ‚Åø.val, [0.0u\"MW\",2.0u\"MW\"])\ntrue\njulia> ugf·µç·µâ‚Åø = UGF(:power, [0.0u\"MW\",0.0u\"MW\",2.0u\"MW\"], [0.1,0.2,0.7], rdc=false)\njulia> isequal(ugf·µç·µâ‚Åø.val, [0.0u\"MW\",0.0u\"MW\",2.0u\"MW\"])\ntrue\n\n\n\n\n\n","category":"type"},{"location":"ugf/#","page":"Generating Functions","title":"Generating Functions","text":"Alternatively, an ugf may be constructed based on a solved state-transition diagram:","category":"page"},{"location":"ugf/#","page":"Generating Functions","title":"Generating Functions","text":"MultiStateSystems.UGF(msr::Symbol, std::MultiStateSystems.AbstractSTD)","category":"page"},{"location":"ugf/#MultiStateSystems.UGF-Tuple{Symbol, MultiStateSystems.AbstractSTD}","page":"Generating Functions","title":"MultiStateSystems.UGF","text":"UGF(msr::Symbol, std::MultiStateSystems.AbstractSTD)\n\nA UGF constructor for a specific measure msr based on a given state-transition diagram std.\n\nThis function automatically reduces the state-space to where only unique values and associated probabilites remain.\n\nExample\n\njulia> std·µç·µâ‚Åø = solvedSTD(prob  = [0.1,0.2,0.7],\n                          power = [0.0u\"MW\",0.0u\"MW\",2.0u\"MW\"])\njulia> ugf·µç·µâ‚Åø = UGF(:power, std·µç·µâ‚Åø)\njulia> isequal(ugf·µç·µâ‚Åø.val,[0.0u\"MW\",2.0u\"MW\"])\ntrue\n\n\n\n\n\n","category":"method"},{"location":"std/#State-Transition-Diagram-1","page":"State-Transition Diagram","title":"State-Transition Diagram","text":"","category":"section"},{"location":"std/#Quick-Links-1","page":"State-Transition Diagram","title":"Quick Links","text":"","category":"section"},{"location":"std/#","page":"State-Transition Diagram","title":"State-Transition Diagram","text":"Pages = [\"std.md\"]","category":"page"},{"location":"std/#Introduction-1","page":"State-Transition Diagram","title":"Introduction","text":"","category":"section"},{"location":"std/#","page":"State-Transition Diagram","title":"State-Transition Diagram","text":"In its essence, a state-transition diagram (abbr: std) is a collections of states and transitions mapped onto a directed graph through metadata on its vertices and edges, respectively.","category":"page"},{"location":"std/#","page":"State-Transition Diagram","title":"State-Transition Diagram","text":"Any state-transition diagram has four attributes:","category":"page"},{"location":"std/#","page":"State-Transition Diagram","title":"State-Transition Diagram","text":"a directed graph std.graph::SimpleDiGraph\nstate-transition diagram properties std.props::PropDict\nstate properties std.sprops::Dict{Int,PropDict}\ntransition properties std.tprops::Dict{Edge,PropDict}","category":"page"},{"location":"std/#Constructors-1","page":"State-Transition Diagram","title":"Constructors","text":"","category":"section"},{"location":"std/#","page":"State-Transition Diagram","title":"State-Transition Diagram","text":"Two constructors are implemented:","category":"page"},{"location":"std/#","page":"State-Transition Diagram","title":"State-Transition Diagram","text":"MultiStateSystems.STD()","category":"page"},{"location":"std/#MultiStateSystems.STD-Tuple{}","page":"State-Transition Diagram","title":"MultiStateSystems.STD","text":"STD()\n\nAn empty state-transition diagram constructor.\n\nExample\n\njulia> std·µç·µâ‚Åø = STD()\n\n\n\n\n\n","category":"method"},{"location":"std/#","page":"State-Transition Diagram","title":"State-Transition Diagram","text":"MultiStateSystems.STD(;prob::Array, kwargs...)","category":"page"},{"location":"std/#Info-1","page":"State-Transition Diagram","title":"Info","text":"","category":"section"},{"location":"std/#","page":"State-Transition Diagram","title":"State-Transition Diagram","text":"A number of properties are defined for state-transition diagrams, states and transitions, respectively captured by (a) STDInfo, (b) StateInfo and (c) TransInfo.","category":"page"},{"location":"std/#","page":"State-Transition Diagram","title":"State-Transition Diagram","text":"markovian [(a),(c)]:   the Markov property refers   to the memoryless property of a stochastic process. It entails that the   conditional probability distribution of future states only depends on the   present state, including calendar time, however, they are independent of the   present state's sojourn time (see: strong Markov property).\nrenewal [(a), (b), (c)]:   the renewal property entails that the stochastic process probabilistically start   over at each arrival epoch. Consequently, a non-renewal transition entails that   its to-state is not necessarily entered with a zero sojourn time.\ntime_homogeneous [(a), (c)]:   the time-homogeneous property   entails that the transition probability between two given states at any two   times depends only on the difference between those times\ntrapping [(b)]:   the trapping property entails that a state is only partially/never exited upon   entering.\nsolved [(a)]:   the solved property describes whether the state probabilities of a   state-transition diagram have been determined.","category":"page"},{"location":"std/#State-1","page":"State-Transition Diagram","title":"State","text":"","category":"section"},{"location":"std/#","page":"State-Transition Diagram","title":"State-Transition Diagram","text":"Any state is represented by a PropDict mapped onto the vertices of the directed graph std.graph. The collection of all states is stored in std.sprops which is a dictionary indexed using the vertex ids [Int].","category":"page"},{"location":"std/#","page":"State-Transition Diagram","title":"State-Transition Diagram","text":"Any property may be added the PropDict representing a state, however certain properties are reserved for specific functionality of the tool, each linked to a specific key [Symbol].","category":"page"},{"location":"std/#","page":"State-Transition Diagram","title":"State-Transition Diagram","text":":info is reserved for the StateInfo\n:init is reserved for the initial state probability p(0) [-]\n:prob is reserved for the state probability p(t) [-]\n:œÜinit is reserved for the initial state sojourn time œÜ(0) [hr]\n:flow is reserved for the state flow measure [m¬≥/hr]\n:power is reserved for the state power measure [MW]","category":"page"},{"location":"std/#","page":"State-Transition Diagram","title":"State-Transition Diagram","text":"States may either be added to state-transition diagram individually or grouped using, respectively:","category":"page"},{"location":"std/#","page":"State-Transition Diagram","title":"State-Transition Diagram","text":"MultiStateSystems.add_state!(std::MultiStateSystems.AbstractSTD; kwargs...)","category":"page"},{"location":"std/#MultiStateSystems.add_state!-Tuple{MultiStateSystems.AbstractSTD}","page":"State-Transition Diagram","title":"MultiStateSystems.add_state!","text":"add_state!(std::MultiStateSystems.AbstractSTD; kwargs...)\n\nAdds a single state to the state-transition diagram std and fills its corresponding PropDict with the named arguments kwargs.\n\nExample\n\njulia> std·µç·µâ‚Åø = STD()\njulia> add_state!(std·µç·µâ‚Åø, name  = \"normal operation state\",\n                          power = 100u\"MW\",\n                          init  = 1.0)\n\n\n\n\n\n","category":"method"},{"location":"std/#","page":"State-Transition Diagram","title":"State-Transition Diagram","text":"MultiStateSystems.add_states!(std::MultiStateSystems.AbstractSTD; kwargs...)","category":"page"},{"location":"std/#MultiStateSystems.add_states!-Tuple{MultiStateSystems.AbstractSTD}","page":"State-Transition Diagram","title":"MultiStateSystems.add_states!","text":"add_states!(std::MultiStateSystems.AbstractSTD; kwargs...)\n\nAdds multiple states to the state-transition diagram std and fills their corresponding PropDict with the named arguments kwargs. Either an uniform argument is given which holds for all states or an array is given with the specific argument for each state.\n\nExample\n\njulia> std·µç·µâ‚Åø = STD()\njulia> add_states!(std·µç·µâ‚Åø, name  = [\"normal operation state\",\"failed state\"],\n                           power = [100.0u\"MW\",0.0u\"MW\"],\n                           init  = [1.0,0.0],\n                           markovian = true)\n\n\n\n\n\n","category":"method"},{"location":"std/#Transition-1","page":"State-Transition Diagram","title":"Transition","text":"","category":"section"},{"location":"std/#","page":"State-Transition Diagram","title":"State-Transition Diagram","text":"Any transition is represented by a PropDict mapped onto the edges of the directed graph std.graph. The collection of all transitions is stored in std.tprops which is a dictionary indexed using the edge ids [Edge].","category":"page"},{"location":"std/#","page":"State-Transition Diagram","title":"State-Transition Diagram","text":"Any property may be added to the PropDict representing a transition, however certain properties are reserved for specific functionality of the tool, each linked to a specific key [Symbol].","category":"page"},{"location":"std/#","page":"State-Transition Diagram","title":"State-Transition Diagram","text":":states is reserved for the tuple (fr,to) of the from- and to-state\n:rate is reserved for the transition rate rho(tœÜ) [1/hr]\n:distr is reserved for the transition distribution\n:type is reserved for the transition type\n:f   - failure\n:p   - preventive maintenance decision\n:r   - recoverability action\n:mcm - minimal corrective maintenance\n:pcm - perfect corrective maintenance\n:ppm - perfect preventive maintenance","category":"page"},{"location":"std/#","page":"State-Transition Diagram","title":"State-Transition Diagram","text":"Transitions may either be added to a state-transition diagram individually or grouped using, respectively:","category":"page"},{"location":"std/#","page":"State-Transition Diagram","title":"State-Transition Diagram","text":"MultiStateSystems.add_transition!(std::MultiStateSystems.AbstractSTD; kwargs...)","category":"page"},{"location":"std/#MultiStateSystems.add_transition!-Tuple{MultiStateSystems.AbstractSTD}","page":"State-Transition Diagram","title":"MultiStateSystems.add_transition!","text":"add_transition!(std::MultiStateSystems.AbstractSTD; kwargs...)\n\nAdds a single transitions to the state-transition diagram std and fills its corresponding PropDict with the named arguments kwargs. One obligatory named argument is :states, describing the tuple (fr,to) of the from- and to-state.\n\nExample\n\njulia> std·µç·µâ‚Åø = STD()\njulia> add_states!(std·µç·µâ‚Åø, name  = [\"normal operation state\",\"failed state\"],\n                           power = [100.0u\"MW\",0.0u\"MW\"],\n                           init  = [1.0,0.0],\n                           markovian = true)\njulia> add_transition!(std·µç·µâ‚Åø, rate = 0.001u\"1/hr\",\n                               states = (1,2))\n\n\n\n\n\n","category":"method"},{"location":"std/#","page":"State-Transition Diagram","title":"State-Transition Diagram","text":"MultiStateSystems.add_transitions!(std::MultiStateSystems.AbstractSTD; kwargs...)","category":"page"},{"location":"std/#MultiStateSystems.add_transitions!-Tuple{MultiStateSystems.AbstractSTD}","page":"State-Transition Diagram","title":"MultiStateSystems.add_transitions!","text":"add_transitions!(std::MultiStateSystems.AbstractSTD; kwargs...)\n\nAdds multiple transitions to the state-transition diagram std and fills their corresponding PropDict with the named arguments kwargs. Either an uniform argument is given which holds for all transitions or an array is given with the specific argument for each transition.\n\nExample\n\njulia> std·µç·µâ‚Åø = STD()\njulia> add_states!(std·µç·µâ‚Åø, name  = [\"normal operation state\",\"failed state\"],\n                           power = [100.0u\"MW\",0.0u\"MW\"],\n                           init  = [1.0,0.0],\n                           markovian = true)\njulia> add_transitions!(std·µç·µâ‚Åø, rate = [0.001u\"1/hr\",0.01u\"1/hr\"],\n                                states = [(1,2),(2,1)])\n\nnote: Note\nIf the :states argument is not provided in the add_transitions! function, the from- and to-states will be determined based on the other arguments.\n\nExample (Alternative)\n\njulia> add_transitions!(std·µç·µâ‚Åø, rate = [0.000u\"1/hr\" 0.010u\"1/hr\"\n                                        0.001u\"1/hr\" 0.000u\"1/hr\"])\n\n\n\n\n\n","category":"method"},{"location":"ugo/#Universal-Generating-Operator-1","page":"Generating Operators","title":"Universal Generating Operator","text":"","category":"section"},{"location":"ugo/#Introduction-1","page":"Generating Operators","title":"Introduction","text":"","category":"section"},{"location":"ugo/#","page":"Generating Operators","title":"Generating Operators","text":"Solving a network ntw through the univeral generating operator may be accomplished through:","category":"page"},{"location":"ugo/#","page":"Generating Operators","title":"Generating Operators","text":"solve!(ntw::MultiStateSystems.AbstractNetwork; type::Symbol=:steady)","category":"page"},{"location":"ugo/#MultiStateSystems.solve!-Tuple{MultiStateSystems.AbstractNetwork}","page":"Generating Operators","title":"MultiStateSystems.solve!","text":"solve!(ntw::MultiStateSystems.AbstractNetwork)\n\nThis function determines the universal generating function related to the output of all users usr of a network ntw.\n\n\n\n\n\n","category":"method"},{"location":"processes/#Stochastic-Processes-1","page":"Stochastic Processes","title":"Stochastic Processes","text":"","category":"section"},{"location":"processes/#Introduction-1","page":"Stochastic Processes","title":"Introduction","text":"","category":"section"},{"location":"processes/#","page":"Stochastic Processes","title":"Stochastic Processes","text":"A number of stochastic processes are available to determine the state probabilities of an std:","category":"page"},{"location":"processes/#","page":"Stochastic Processes","title":"Stochastic Processes","text":"Steady state process SteadyStateProcess <: AbstractMarkovProcess\nMarkov chain :markov_process\nMarkov process :markov_process\nSemi-Markov process :semimarkov_process\nVan Acker process :vanacker_process","category":"page"},{"location":"processes/#","page":"Stochastic Processes","title":"Stochastic Processes","text":"Solving a stochastic process may be accomplished through:","category":"page"},{"location":"processes/#","page":"Stochastic Processes","title":"Stochastic Processes","text":"solve!(std::MultiStateSystems.AbstractSTD, tsim::Number; alg::Symbol=:nothing)","category":"page"},{"location":"processes/#Steady-State-Process-1","page":"Stochastic Processes","title":"Steady State Process","text":"","category":"section"},{"location":"processes/#","page":"Stochastic Processes","title":"Stochastic Processes","text":"Spaces  Properties \nState-space discrete Renewal ‚úÖ\nTime-space singular (t=‚àû) Markov ‚úÖ","category":"page"},{"location":"processes/#","page":"Stochastic Processes","title":"Stochastic Processes","text":"A steady state process determines the state-state probability of the state space associated with a time-homogeneous Markov process/chain, i.e., where t‚Üí‚àû.","category":"page"},{"location":"processes/#","page":"Stochastic Processes","title":"Stochastic Processes","text":"https://www.maplesoft.com/support/help/maple/view.aspx?path=examples/SteadyStateMarkovChain","category":"page"},{"location":"processes/#Markov-Process-1","page":"Stochastic Processes","title":"Markov Process","text":"","category":"section"},{"location":"processes/#","page":"Stochastic Processes","title":"Stochastic Processes","text":"Spaces  Properties \nState-space discrete Renewal ‚úÖ\nTime-space continuous Markov ‚úÖ","category":"page"},{"location":"processes/#","page":"Stochastic Processes","title":"Stochastic Processes","text":"A Markov process is described by a random variable X_t, where t denotes the calendar time. The possible values of X_t are represented by the discrete state-space ùì¢ of the state transition diagram std.","category":"page"},{"location":"processes/#","page":"Stochastic Processes","title":"Stochastic Processes","text":"A Markov process respects the Markov property, which means it respects","category":"page"},{"location":"processes/#","page":"Stochastic Processes","title":"Stochastic Processes","text":"‚Ñô(X_t  ùì¢  ùìï_s) = ‚Ñô(X_t  ùì¢  X_s)  st  ùïÄ s  t","category":"page"},{"location":"processes/#","page":"Stochastic Processes","title":"Stochastic Processes","text":"where ùìï_s represents a filtration of a probability space (Œ©,ùìï,‚Ñô) and ùïÄ a totally ordered index set. A Markov process is described by Kolmogorov equations, more specifically the Kolmogorov forward equations:","category":"page"},{"location":"processes/#","page":"Stochastic Processes","title":"Stochastic Processes","text":" Œ¥p_ij(st)Œ¥t = _k p_ik(st)  A_kj(t)  ij  ùì¢ st  ùïÄ s  t","category":"page"},{"location":"processes/#","page":"Stochastic Processes","title":"Stochastic Processes","text":"where A(t) represents the transition matrix, syn., generator matrix. The latter may be translated into an initial value problem for finding the state probabilities, given transition rates œÅ_ij(t) and initial values Œ¥_i:","category":"page"},{"location":"processes/#","page":"Stochastic Processes","title":"Stochastic Processes","text":"dp_i(t)dt = - _j œÅ_ij(t)p_i(t) + _j œÅ_ji(t)p_j(t)   i  ùì¢","category":"page"},{"location":"processes/#Van-Acker-Process-1","page":"Stochastic Processes","title":"Van Acker Process","text":"","category":"section"},{"location":"processes/#","page":"Stochastic Processes","title":"Stochastic Processes","text":"T. Van Acker, and D. Van Hertem (2018). Stochastic Process for the  Availability Assessment of Single-Feeder Industrial Energy System Sections.  IEEE Trans. on Rel., 67(4), 1459-1467.","category":"page"},{"location":"processes/#","page":"Stochastic Processes","title":"Stochastic Processes","text":"Spaces  Properties \nState-space semi-continuous Renewal ‚ùé[1]\nTime-space continuous Markov ‚ùé","category":"page"},{"location":"processes/#","page":"Stochastic Processes","title":"Stochastic Processes","text":"[1]: The normal operation state can be a non-renewal state, enabling imperfect   maintenance.","category":"page"},{"location":"processes/#","page":"Stochastic Processes","title":"Stochastic Processes","text":"An Van Acker process is described by a random variable X_tœÜ, where t denotes the calendar time. The possible values of X_tœÜ are represented by the semi-continuous state-space ùì¢ of the state transition diagram std and œÜ_s denotes its state sojourn time.","category":"page"},{"location":"processes/#","page":"Stochastic Processes","title":"Stochastic Processes","text":"An Van Acker process is described by a single PDDE with non-local boundary condition for the normal operation state n  ùìù, from which all state probabilies of the other states may be derived.","category":"page"},{"location":"processes/#","page":"Stochastic Processes","title":"Stochastic Processes","text":"beginaligned\nfracp_nœÜ_n + fracp_nt = - sum_f  ùìï Œª_f(tœÜ_n) p_n(tœÜ_n)                            \n                                           + sum_f  ùìï^textmin (ùñø_f * Œª_fp_n)(tœÜ_n)                \n                              p_n(t0)  =   sum_f  ùìï^textper int_0^ (ùñø_f * Œª_fp_n)(tœÜ_n) ùñΩœÜ_f\nendaligned","category":"page"},{"location":"processes/#","page":"Stochastic Processes","title":"Stochastic Processes","text":"where, ùìï, ùìï^textmin and ùìï^textper denote the overall failure set and the failure sets respecively involving minimal and perfect maintenance. The parameters Œª_f and ùñø_f respectively denote the failure rate and restoration pdf associated with a specific failure f  ùìï. The restoration pdf is the sum of the convolutions of transition pdf's along all paths involving a specific failure f  ùìï but excluding that failure's transition pdf.","category":"page"},{"location":"processes/#","page":"Stochastic Processes","title":"Stochastic Processes","text":"!!! The normal operation state is selected by setting that state's initial value  :init to 1.0.","category":"page"},{"location":"processes/#","page":"Stochastic Processes","title":"Stochastic Processes","text":"The problem structure permits descretization of the solution space into cohorts a  ùìê t = œÜ_n + t_a, where t_a is the time for which a cohort a has a zero sojourn time œÜ_n; translating the PDDE into an non-homogeneous first order ODE.","category":"page"},{"location":"processes/#","page":"Stochastic Processes","title":"Stochastic Processes","text":"beginaligned\nfracùñΩp_anùñΩœÜ_n = - sum_f  ùìï Œª_af(œÜ_n) p_an(œÜ_n)                                         \n                         + sum_f  ùìï^textmin sum_x  ùìß barùñø_fx Œª_a-xf(œÜ_n) p_a-xn(œÜ_n) \n            p_an(0)  =   sum_f  ùìï^textper sum_x  ùìß barùñø_fx Œª_a-xf(œÜ_f) p_a-xn(œÜ_f) ùñΩœÜ_f\nendaligned","category":"page"},{"location":"processes/#","page":"Stochastic Processes","title":"Stochastic Processes","text":"Using the solution for the normal operation state probability, all other state probabilities p_p(tvarphi_p)p  ùìü may be determined.","category":"page"},{"location":"processes/#","page":"Stochastic Processes","title":"Stochastic Processes","text":"beginaligned\np_p(tvarphi_p)  = sum_c  ùìí_p f  c (ùñø^textpre_cp*p_f)(t-œÜ_p) R_cp(œÜ_p)   \np_f(t)              = int_0^infty Œª_f(tœÜ_n) p_n(tvarphi_n)ùñΩœÜ_n\nendaligned","category":"page"},{"location":"processes/#","page":"Stochastic Processes","title":"Stochastic Processes","text":"where ùìí_p is the set of simple cycles going through the state p and the pdf ùó≥^textpre_cp convolutions of the transition pdf's of a cycle starting from the normal operation state n up to state p excluding the failure transition.","category":"page"},{"location":"dependence/#Dependence-1","page":"Dependence","title":"Dependence","text":"","category":"section"},{"location":"dependence/#Quick-Links-1","page":"Dependence","title":"Quick Links","text":"","category":"section"},{"location":"dependence/#","page":"Dependence","title":"Dependence","text":"Pages = [\"dependence.md\"]","category":"page"},{"location":"dependence/#Introduction-1","page":"Dependence","title":"Introduction","text":"","category":"section"},{"location":"dependence/#","page":"Dependence","title":"Dependence","text":"Many forms of dependence exists ","category":"page"},{"location":"dependence/#Evaluation-Dependence-1","page":"Dependence","title":"Evaluation Dependence","text":"","category":"section"},{"location":"#MultiStateSystems.jl-1","page":"Home","title":"MultiStateSystems.jl","text":"","category":"section"},{"location":"#Overview-1","page":"Home","title":"Overview","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"MultiStateSystems.jl is a Julia package to solve multi-state systems, often found in reliability engineering.","category":"page"},{"location":"#Installation-1","page":"Home","title":"Installation","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"The latest stable release of MultiStateSystems can be installed using the Julia package manager:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"] add MultiStateSystems","category":"page"},{"location":"#","page":"Home","title":"Home","text":"In order to test whether the package works, run:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"] test MultiStateSystems","category":"page"},{"location":"network/#Network-1","page":"Network","title":"Network","text":"","category":"section"},{"location":"network/#Quick-Links-1","page":"Network","title":"Quick Links","text":"","category":"section"},{"location":"network/#","page":"Network","title":"Network","text":"Pages = [\"network.md\"]","category":"page"},{"location":"network/#Introduction-1","page":"Network","title":"Introduction","text":"","category":"section"},{"location":"network/#","page":"Network","title":"Network","text":"In its essence, a network (abbr: ntw) is a collection of sources, components and users mapped onto a directed multigraph.","category":"page"},{"location":"network/#","page":"Network","title":"Network","text":"Any network has eight attributes:","category":"page"},{"location":"network/#","page":"Network","title":"Network","text":"a multigraph ntw.graph::DiMultigraph\nnetwork properties ntw.props::PropDict\ncomponents ntw.cmp::Vector{PropDict}\nsources ntw.src::Vector{PropDict}\nusers ntw.usr::Vector{PropDict}\ncomponent library ntw.clib::LibDict\nsource library ntw.slib::LibDict\nusers library ntw.ulib::LibDict","category":"page"},{"location":"network/#Constructors-1","page":"Network","title":"Constructors","text":"","category":"section"},{"location":"network/#","page":"Network","title":"Network","text":"One constructor is implemented:","category":"page"},{"location":"network/#","page":"Network","title":"Network","text":"MultiStateSystems.Network()","category":"page"},{"location":"network/#MultiStateSystems.Network-Tuple{}","page":"Network","title":"MultiStateSystems.Network","text":"Network()\n\nAn network constructor.\n\nExample\n\njulia> ntw = Network()\n\n\n\n\n\n","category":"method"},{"location":"network/#Info-1","page":"Network","title":"Info","text":"","category":"section"},{"location":"network/#","page":"Network","title":"Network","text":"A number of properties are defined for networks captured by NetworkInfo.","category":"page"},{"location":"network/#","page":"Network","title":"Network","text":"solved:   the solved property describes whether the ugf of a network's users have been   determined.\ndependent_source:   the dependent source property flags that the output of all sources in the   network are dependent on an uniform source, e.g., wind turbines in a single   windfarm.","category":"page"},{"location":"network/#Component-1","page":"Network","title":"Component","text":"","category":"section"},{"location":"network/#","page":"Network","title":"Network","text":"Any component (abbr: cmp) is represented by a PropDict mapped onto either the vertices or edges of the multigraph ntw.graph. The collection of all components is stored in ntw.cmp, which is a vector.","category":"page"},{"location":"network/#","page":"Network","title":"Network","text":"The link between the component id, i.e., its index in ntw.cmp, and the vertex/edge of ntw.graph to which it is mapped is stored in ntw.clib (key: vertex/edge, value: [cmp...]).","category":"page"},{"location":"network/#","page":"Network","title":"Network","text":"Any property may be added to the Propdict representing the component, however certain properties are reserved for specific functionality of the tool, each linked to a specific key [Symbol].","category":"page"},{"location":"network/#","page":"Network","title":"Network","text":":node is reserved for the component's node in the multigraph ntw.graph\n:edge is reserved for the component's edge in the multigraph ntw.graph\n:std is reserved for the state-transition diagram of the component","category":"page"},{"location":"network/#","page":"Network","title":"Network","text":"note: Note\nIn order to link the specific component to either a vertex or an edge of the network, it is obligatory to provide them through the named argument :node or :edge, respectively.","category":"page"},{"location":"network/#","page":"Network","title":"Network","text":"Components may either be added to a network individually or grouped using, respectively:","category":"page"},{"location":"network/#","page":"Network","title":"Network","text":"add_component!(ntw::MultiStateSystems.AbstractNetwork; kwargs...)","category":"page"},{"location":"network/#MultiStateSystems.add_component!-Tuple{MultiStateSystems.AbstractNetwork}","page":"Network","title":"MultiStateSystems.add_component!","text":"add_components!(ntw::MultiStateSystems.AbstractNetwork; kwargs...)\n\nAdds a single component to the network ntw and fills their corresponding PropDict with the named arguments kwargs.\n\nExample\n\njulia> ntw·µñ ∑ ≥ = ntw()\njulia> add_components!(ntw·µñ ∑ ≥, edge = (1,2),\n                               name = \"cable 1\",\n                               std  = STD(power = [0u\"MW\",1500u\"MW\"],\n                                          prob  = [0.2,0.8]))\n\n\n\n\n\n","category":"method"},{"location":"network/#","page":"Network","title":"Network","text":"add_components!(ntw::MultiStateSystems.AbstractNetwork; kwargs...)","category":"page"},{"location":"network/#MultiStateSystems.add_components!-Tuple{MultiStateSystems.AbstractNetwork}","page":"Network","title":"MultiStateSystems.add_components!","text":"add_components!(ntw::MultiStateSystems.AbstractNetwork; kwargs...)\n\nAdds multiple components to the network ntw and fills their corresponding PropDict with the named arguments kwargs. Either an uniform arguments is given which holds for all components or an array is given whith specific argument for each component.\n\nExample\n\njulia> ntw·µñ ∑ ≥ = ntw()\njulia> add_components!(ntw·µñ ∑ ≥, edge = [(1,2),(1,2),(2,3)],\n                               name = [\"cable 1\",\"cable 2\",\"cable 3\"],\n                               std  = [STD(power = [0u\"MW\",1500u\"MW\"],\n                                           prob  = [0.2,0.8]),\n                                       STD(power = [0u\"MW\",2000u\"MW\"],\n                                           prob  = [0.4,0.6]),\n                                       STD(power = [0u\"MW\",1800u\"MW\",4000u\"MW\"],\n                                           prob = [0.1,0.2,0.7])])\n\n\n\n\n\n","category":"method"},{"location":"network/#Source-1","page":"Network","title":"Source","text":"","category":"section"},{"location":"network/#","page":"Network","title":"Network","text":"Any source (abbr: src) is represented by a PropDict mapped onto either the vertices of the multigraph ntw.graph. The collection of all sources is stored in ntw.src, which is a vector.","category":"page"},{"location":"network/#","page":"Network","title":"Network","text":"The link between the source id, i.e., its index in ntw.src, and the vertex of ntw.graph to which it is mapped is stored in ntw.slib (key: vertex, value: [cmp...]).","category":"page"},{"location":"network/#","page":"Network","title":"Network","text":"Any property may be added to the Propdict representing the source, however certain properties are reserved for specific functionality of the tool, each linked to a specific key [Symbol].","category":"page"},{"location":"network/#","page":"Network","title":"Network","text":":node is reserved for the source's node in the multigraph ntw.graph\n:std is reserved for the state-transition diagram of the source\n:ntw is reserved for the tuple (ntw,usr) representing the source, where usr is the user-id [Int] of the network ntw.\n:dep_source is reserved for the dependent_source property.\n:dep_eval is reserved for the dependent_evaluation property.","category":"page"},{"location":"network/#","page":"Network","title":"Network","text":"note: Note\nIn order to link the specific source to a vertex of the network, it is obligatory to provide them through the named argument :node.","category":"page"},{"location":"network/#","page":"Network","title":"Network","text":"Sources may either be added to a network individually or grouped using, respectively:","category":"page"},{"location":"network/#","page":"Network","title":"Network","text":"add_source!(ntw::MultiStateSystems.AbstractNetwork; kwargs...)","category":"page"},{"location":"network/#MultiStateSystems.add_source!-Tuple{MultiStateSystems.AbstractNetwork}","page":"Network","title":"MultiStateSystems.add_source!","text":"add_source!(ntw::MultiStateSystems.AbstractNetwork; kwargs...)\n\nAdds a single source to the network ntw and fills their corresponding PropDict with the named arguments kwargs.\n\nExample\n\njulia> ntw·µñ ∑ ≥ = ntw()\njulia> std·µç·µâ‚Åø = solvedSTD(prob = [0.1,0.2,0.7],\n                          flow = [0.0u\"MW\",0.5u\"MW\",2.0u\"MW\"])\njulia> add_source!(ntw·µñ ∑ ≥, node = 1,\n                           name = \"generator 1\",\n                           std  = std·µç·µâ‚Åø)\n\n\n\n\n\n","category":"method"},{"location":"network/#","page":"Network","title":"Network","text":"add_sources!(ntw::MultiStateSystems.AbstractNetwork; kwargs...)","category":"page"},{"location":"network/#Users-1","page":"Network","title":"Users","text":"","category":"section"},{"location":"network/#","page":"Network","title":"Network","text":"Any user (abbr: usr) is represented by a PropDict mapped onto either the vertices of the multigraph ntw.graph. The collection of all users is stored in ntw.usr, which is a vector.","category":"page"},{"location":"network/#","page":"Network","title":"Network","text":"The link between the user id, i.e., its index in ntw.usr, and the vertex of ntw.graph to which it is mapped is stored in ntw.ulib (key: vertex, value: [cmp...]).","category":"page"},{"location":"network/#","page":"Network","title":"Network","text":"Any property may be added to the Propdict representing the user, however certain properties are reserved for specific functionality of the tool, each linked to a specific key [Symbol].","category":"page"},{"location":"network/#","page":"Network","title":"Network","text":":node is reserved for the user's vertex in the multigraph ntw.graph\n:std is reserved for the state-transition diagram of the user\n:ind is reserved for the user's indices","category":"page"},{"location":"network/#","page":"Network","title":"Network","text":"note: Note\nIn order to link the specific user to a vertex of the network, it is obligatory to provide them through the named argument :node.","category":"page"},{"location":"network/#","page":"Network","title":"Network","text":"Users may either be added to a network individually or grouped using, respectively:","category":"page"},{"location":"network/#","page":"Network","title":"Network","text":"add_user!(ntw::MultiStateSystems.AbstractNetwork; kwargs...)","category":"page"},{"location":"network/#MultiStateSystems.add_user!-Tuple{MultiStateSystems.AbstractNetwork}","page":"Network","title":"MultiStateSystems.add_user!","text":"add_user!(ntw::MultiStateSystems.AbstractNetwork; kwargs...)\n\nAdds a single user to the network ntw and fills their corresponding PropDict with the named arguments kwargs.\n\nExample\n\njulia> ntw·µñ ∑ ≥ = ntw()\njulia> add_source!(ntw·µñ ∑ ≥, node = 1,\n                           ind  = [:EENS])\n\n\n\n\n\n","category":"method"},{"location":"network/#","page":"Network","title":"Network","text":"add_users!(ntw::MultiStateSystems.AbstractNetwork; kwargs...)","category":"page"},{"location":"network/#MultiStateSystems.add_users!-Tuple{MultiStateSystems.AbstractNetwork}","page":"Network","title":"MultiStateSystems.add_users!","text":"add_users!(ntw::MultiStateSystems.AbstractNetwork; kwargs...)\n\nAdds multiple users to the network ntw and fills their corresponding PropDict with the named arguments kwargs. Either an uniform arguments is given which holds for all components or an array is given whith specific argument for each component.\n\nExample\n\njulia> ntw·µñ ∑ ≥ = ntw()\njulia> add_sources!(ntw·µñ ∑ ≥, node = [1,5,8],\n                            ind  = [:EENS])\n\n\n\n\n\n","category":"method"}]
}
